// function floodFill(e) {
//     if (!isFloodFillActive || !curCtx) return;

//     const rect = layers[currentLayer].getBoundingClientRect();
//     const startX = Math.floor((e.clientX - rect.left) / zoomLevel);
//     const startY = Math.floor((e.clientY - rect.top) / zoomLevel);

//     console.log(`Flood fill starting at (${startX}, ${startY})`);

//     const imageData = curCtx.getImageData(0, 0, realWidth, realHeight);
//     const data = imageData.data;
//     const targetColor = getPixelColor2(startX, startY); // Pass startX and startY directly
//     const fillColor = hexToRgba(colorPicker.value);
//     const tolerance = 30;

//     if (colorMatch(targetColor, fillColor, tolerance)) return;

//     const stack = [[startX, startY]];
//     const visited = new Uint8Array(realWidth * realHeight);

//     while (stack.length) {
//         const [x, y] = stack.pop();
//         const index = y * realWidth + x;
//         if (visited[index]) continue;
//         visited[index] = 1;

//         const pixelIndex = index * 4;
//         const currentColor = data.slice(pixelIndex, pixelIndex + 4);

//         if (colorMatch(currentColor, targetColor, tolerance) || isContourPixel(x, y, data, realWidth, realHeight, targetColor, tolerance)) {
//             setPixelColor(data, x, y, realWidth, fillColor);
//             if (x > 0) stack.push([x - 1, y]);
//             if (x < realWidth - 1) stack.push([x + 1, y]);
//             if (y > 0) stack.push([x, y - 1]);
//             if (y < realHeight - 1) stack.push([x, y + 1]);
//         }
//     }

//     curCtx.putImageData(imageData, 0, 0);
//     saveState();
//     layerDrawnOn[currentLayer] = true;
//     updateLayerEyeIcon(currentLayer);

// function isContourPixel(x, y, data, width, height, targetColor, tolerance) {
//     const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
//     for (const [dx, dy] of directions) {
//         const nx = x + dx;
//         const ny = y + dy;
//         if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
//             const neighborColor = getPixelColor2(data, nx, ny, width);
//             if (!colorMatch(neighborColor, targetColor, tolerance)) {
//                 return true;
//             }
//         }
//     }
//     return false;
// }

//     function setPixelColor(data, x, y, width, color) {
//         const index = (y * width + x) * 4;
//         data[index] = color[0];
//         data[index + 1] = color[1];
//         data[index + 2] = color[2];
//         data[index + 3] = color[3];
//     }

//     // Оптимизированный дополнительный проход
//     for (let y = 0; y < realHeight; y++) {
//         for (let x = 0; x < realWidth; x++) {
//             const index = (y * realWidth + x) * 4;
//             if (!colorMatch(data.slice(index, index + 4), fillColor, 0) && shouldFillPixel(x, y, data, realWidth, realHeight, fillColor)) {
//                 setPixelColor(data, x, y, realWidth, fillColor);
//             }
//         }
//     }

//     curCtx.putImageData(imageData, 0, 0);
//     saveState();
//     layerDrawnOn[currentLayer] = true;
//     updateLayerEyeIcon(currentLayer);
// }

// // Добавьте обработчик события для canvasContainer
// canvasContainer.addEventListener('click', (e) => {
//     if (isFloodFillActive) {
//         floodFill(e);
//     }
// });
// function shouldFillPixel(x, y, data, width, height, fillColor) {
//       const directions = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];
//       let filledNeighbors = 0;
//       for (const [dx, dy] of directions) {
//         const nx = x + dx;
//         const ny = y + dy;
//         if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
//           const neighborColor = getPixelColor2(data, nx, ny, width);
//           if (colorMatch(neighborColor, fillColor, 0)) {
//             filledNeighbors++;
//           }
//         }
//       }
//       return filledNeighbors >= 5;
//     }
// function hexToRgba(hex) {
//       const r = parseInt(hex.slice(1, 3), 16);
//       const g = parseInt(hex.slice(3, 5), 16);
//       const b = parseInt(hex.slice(5, 7), 16);
//       return [r, g, b, 255];
//     }
// function colorMatch(a, b, tolerance) {
//       return Math.abs(a[0] - b[0]) <= tolerance &&
//              Math.abs(a[1] - b[1]) <= tolerance &&
//              Math.abs(a[2] - b[2]) <= tolerance &&
//              Math.abs(a[3] - b[3]) <= tolerance;
//     }