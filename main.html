<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–ù–∞—Å—Ç–æ—è—â–∏–π –•—É–¥–æ–∂–Ω–∏–∫</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/jscolor/2.4.5/jscolor.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script> -->
</head>

<body>
    <div class="base-container">
        <div class="sidebar">
            <a href="index.html" target="_self" title="–í—ã–π—Ç–∏ –∏–∑ –∫–æ–º–∞–Ω—Ç—ã" id="exitLink">üö™</a>
            <button id="message" title="–°–æ–æ–±—â–µ–Ω–∏–µ">‚úâÔ∏è</button>


            <button id="floodFillBtn" title="–ó–∞–ª–∏–≤–∫–∞">üåä</button>
            <button id="mergeDownBtn" title="–°–ª–∏—Ç—å co —Å–ª–æ–µ–º –Ω–∏–∂–µ">üîΩ</button>
            <button id="backgroundSettingsBtn" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ñ–æ–Ω–∞">üñºÔ∏è</button>
            <button id="canvasSettingsBtn" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–∞–Ω–≤–∞—Å–∞">üñåÔ∏è</button>
            <button id="fullscreenBtn" title="–ü–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π —Ä–µ–∂–∏–º">üî≤</button>
            <button id="spider" title="–ü–∞—É—Ç–∏–Ω–∫–∞">üï∑Ô∏è</button>
            <button id="fingerBtn" title="–°—É–∂–µ–Ω–∏–µ –∫ —Ü–µ–Ω—Ç—Ä—É">üéØ</button>
            <button id="identifyLayerBtn" title="–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å–ª–æ–π">üîç</button>
            <button id="drawOnExistingBtn" title="–†–∏—Å–æ–≤–∞—Ç—å –Ω–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–º">‚û°Ô∏è</button>
            <input type="file" id="imageInput" accept="image/*" style="display: none;">
            <button id="UploadB" title="–ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (U)">üå∫</button>
            <button id="saveImageBtn" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ">üé¨</button>
            <button id="eraserBtn">üßΩ</button>
            <button id="changeCursorBtn" title="–°–º–µ–Ω–∏—Ç—å –∫—É—Ä—Å–æ—Ä">üé®</button>
            <button id="undoBtn" title="–û—Ç–º–µ–Ω–∏—Ç—å (Z)">‚ü≤</button>
            <button id="redoBtn" title="–ü–æ–≤—Ç–æ—Ä–∏—Ç—å (X)">‚ü≥</button>
            <button id="clear" title="–û—á–∏—Å—Ç–∏—Ç—å">üíÄ</button>

            <button id="eyedropperBtn" title="–ü–∏–ø–µ—Ç–∫–∞ (A)">üíß</button>
            <button id="deleteAllBtn" title="–£–¥–∞–ª–∏—Ç—å –≤—Å–µ">üóëÔ∏è</button>
            <button id="mergeLayers" title="–û–±—ä–µ–¥–∏–Ω–∏—Ç—å —Å–ª–æ–∏">üîó</button>
            <button id="settings" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏">‚öôÔ∏è</button>
        </div>
        <div id="colorPreview"></div>
        <div class="canvas-and-sliders">
            <div class="layer-panel-wrapper">
                <button id="moveLayerUp" title="–°–ª–æ–π –≤–≤–µ—Ä—Ö">‚ñ≤</button>
                <div class="layer-panel">
                    <div id="layerButtons"></div>
                </div>
                <button id="moveLayerDown" title="–°–ª–æ–π –≤–Ω–∏–∑">‚ñº</button>
            </div>
            <div class="canvas-container">
            <div id="message-container" class="message-popup">
                <p id="message-text"></p>
            </div>

                <div class="color-picker-and-word">
                    <div class="color-picker-group">
                        <input type="color" id="colorPicker" value="#000000" title="–¶–≤–µ—Ç –∑–∞–ª–∏–≤–∫–∏ (C)">
                        <input type="color" id="colorPicker2" value="#ffffff" title="–±—É–ª—ã–π">
                        <input type="color" id="colorPicker3" value="#ff0000" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 3">
                        <input type="color" id="colorPicker4" value="#ffa500" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 4">
                        <input type="color" id="colorPicker5" value="#ffff00" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 5">
                        <input type="color" id="colorPicker6" value="#008000" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 6">
                        <input type="color" id="colorPicker7" value="#00ffff" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 7">
                        <input type="color" id="colorPicker8" value="#0000ff" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 8">
                        <input type="color" id="colorPicker9" value="#800080" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 9">
                        <input type="color" id="backgroundPicker" value="#ffffff" title="–¶–≤–µ—Ç —Ñ–æ–Ω–∞ (B)">
                        <div class="color-picker-group-two">
                        </div>
                        <button id="symmetry" title="–°–∏–º–º–µ—Ç—Ä–∏—è (S)">ü¶ã</button>
                    </div>
                    <div class="word-navigation">
                        <button id="previousWord" title="–ü—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–ª–æ–≤–æ">&lt;</button>
                        <p id="Quizz"></p>
                        <button id="nextWord" title="–°–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ">&gt;</button>
                    </div>
                    <div class="header-container">
                        <div class="time-wrapper">
                            <span id="time" class="time"></span>
                            <span id="startTime" class="time"></span>
                            <span id="elapsedTime" class="time"></span>
                            <button id="zoomBtn" title="–õ—É–ø–∞"></button>
                            <div id="zoomLevelDisplay" title="–£—Ä–æ–≤–µ–Ω—å –∑—É–º–∞"></div>
                        </div>
                    </div>
                </div>
                <div class="canv-container" id="canvasContainer">
                    <div id="cursorPanel" class="cursor-panel" style="display: none;">
                        <h3>–í—ã–±–µ—Ä–∏—Ç–µ –∫—É—Ä—Å–æ—Ä</h3>
                        <div id="cursorList"></div>
                    </div>
                </div>
                <div class="sliders">
                    <label for="spiderStrength" title="–°–∏–ª–∞ –ø–∞—É–∫–∞" style="display: none;">üï∏Ô∏è</label>
                    <input type="range" id="spiderStrength" min="50" max="10000" value="1000" title="–°–∏–ª–∞ –ø–∞—É–∫–∞"
                        style="display: none;">
                </div>
                <div class="sliders">
                    <label for="opacity" title="–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å">üëª</label>
                    <input type="range" id="opacity" min="1" max="100" value="100">
                    <span id="opacityValue" style="color: red;">100</span>
                    <label for="layerOpacitySlider" title="–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å —Å–ª–æ—è">üëì</label>
                    <input type="range" id="layerOpacitySlider" min="0" max="100" value="100">
                    <span id="layerOpacityValue" style="color: red;">100</span>
                </div>
                <div class="sliders">
                    <label for="brushSize" title="–†–∞–∑–º–µ—Ä –∫–∏—Å—Ç–∏">üñåÔ∏è</label>
                    <input type="range" id="brushSize" min="1" max="300" value="3">
                    <span id="brushSizeValue" style="color: red;">3</span>
                    <div class="sliders">
                        <div class="pressure-bar-container">
                            <label for="pressureBar" title="–ù–∞–∂–∏–º">üéØ</label>
                            <progress id="pressureBar" value="0" max="4000"></progress>
                            <span id="pressureValue" class="pressure-value"></span>
                        </div>
                        <!-- <input type="number" id="resolutionWidth" value="2000">
<input type="number" id="resolutionHeight" value="2000">
<button onclick="updateResolutionSettings()">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</button> -->
                    </div>
                    <label for="outlineSize" title="–†–∞–∑–º–µ—Ä –æ–±–≤–æ–¥–∫–∏">üñºÔ∏è</label> <span
                        style="font-size: 1.5em;">&#8690;</span>
                    <input type="range" id="outlineSize" min="0" max="20" value="0">
                    <span id="outlineSizeValue" style="color: red;">0</span>
                    <button id="toggleOutlineTypeBtn" title="–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Ç–∏–ø –æ–±–≤–æ–¥–∫–∏">üîÑ</button>
                    <input type="color" id="outlineColorPicker" value="#000000" title="–¶–≤–µ—Ç –æ–±–≤–æ–¥–∫–∏">
                    <button id="applyOutlineBtn" title="–ü—Ä–∏–º–µ–Ω–∏—Ç—å –æ–±–≤–æ–¥–∫—É">‚úÖ</button>
                </div>
                <div class="filter-sliders">
                    <label for="lightnessSlider" title="–°–≤–µ—Ç–ª–æ—Å—Ç—å">üåë</label>
                    <input type="range" id="lightnessSlider" min="0" max="100" value="100">
                    <span id="lightnessValue" style="color: red;">100</span>
                    <label for="saturationSlider" title="–¶–≤–µ—Ç–Ω–æ—Å—Ç—å">üé®</label>
                    <input type="range" id="saturationSlider" min="0" max="200" value="100">
                    <span id="saturationValue" style="color: red;">200</span>
                    <label for="contrastSlider" title="–ö–æ–Ω—Ç—Ä–∞—Å—Ç">üîÜ</label>
                    <input type="range" id="contrastSlider" min="0" max="1000" value="100">
                    <span id="contrastValue" style="color: red;">200</span>
                    <label for="hueShiftSlider" title="–¶–≤–µ—Ç–æ–≤–æ–π —Å–¥–≤–∏–≥">üåà</label>
                    <input type="range" id="hueShiftSlider" min="0" max="360" value="0">
                    <span id="hueShiftValue" style="color: red;">0</span>
                </div>
                <div id="backgroundSettingsModal" class="modal">
                    <div class="modal-content">
                        <span id="closeModal" style="float:right;cursor:pointer;">&times;</span>
                        <input type="color" id="backgroundColorPicker" value="#ffffff">
                        <br><br>
                        <input type="file" id="backgroundImageInput" accept="image/*" multiple>
                        <div id="backgroundImageGallery" style="display: flex; flex-wrap: wrap; margin-top: 10px;">
                        </div>
                        <div id="backgroundPreview"
                            style="display: none; position: absolute; z-index: 1000; border: 2px solid #000;"></div>
                    </div>
                    <!-- Canvas Settings Modal -->
                    <div id="canvasSettingsModal" class="modal">
                        <div class="modal-content">
                            <span id="closeCanvasModal" style="float:right;cursor:pointer;">&times;</span>
                            <input type="color" id="canvasColorPicker" value="#000000">
                            <br><br>
                            <input type="file" id="canvasImageInput" accept="image/*">
                            <div id="canvasImageGallery" style="display: flex; flex-wrap: wrap; margin-top: 10px;">
                            </div>
                        </div>
                    </div>
                    <script>
// –º—ç–π–Ω
    // –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞ –¥–ª—è —Å–æ–∫—Ä–∞—â–µ–Ω–∏—è –∫–æ–¥–∞!
    const gel = id => document.getElementById(id);
                        gel('canvasContainer').style.width = '100%';
                        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ä–∞–∑–º–µ—Ä–æ–≤
                        let displayWidth = 600;
                        let displayHeight = 400;
                        let realWidth = displayWidth;
                        let realHeight = displayWidth;

                        let scale = displayWidth / realWidth;
                        const layerFilters = {};
                    </script>
                    <script>
                        // —Ñ–∏–ª—å—Ç—Ä—ã

                        const filterSliders = [
                            'lightnessSlider',
                            'saturationSlider',
                            'contrastSlider',
                            'hueShiftSlider'
                        ];

                        filterSliders.forEach(sliderId => {
                            gel(sliderId).addEventListener('input', updateFilters);
                        });

                        function updateFilters() {
                            const brightness = lightnessSlider.value;
                            const saturation = saturationSlider.value;
                            const contrast = contrastSlider.value;
                            const hueShift = hueShiftSlider.value;

                            lightnessValue.textContent = brightness;
                            saturationValue.textContent = saturation;
                            contrastValue.textContent = contrast;
                            hueShiftValue.textContent = hueShift;

                            const filterString = `brightness(${brightness}%) saturate(${saturation}%) contrast(${contrast}%) hue-rotate(${hueShift}deg)`;

                            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ —Å–ª–æ—è
                            layerFilters[currentLayer] = filterString;

                            // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä –∫ —Ç–µ–∫—É—â–µ–º—É —Å–ª–æ—é
                            layers[currentLayer].style.filter = filterString;
                        }
                        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Ñ–∏–ª—å—Ç—Ä–æ–≤ –∫ —Å–ª–æ—é
                        function applyFiltersToLayer(layerId) {
                            const brightness = lightnessSlider.value;
                            const saturation = saturationSlider.value;
                            const contrast = contrastSlider.value;
                            const hueShift = hueShiftSlider.value;

                            layers[layerId].style.filter = `brightness(${brightness}%) saturate(${saturation}%) contrast(${contrast}%) hue-rotate(${hueShift}deg)`;
                        }

                    </script>
                    <script>
                        const symmetricPoints = []; // –¥–ª—è –ø–∞—É–∫–∞
                        const back = 0 // –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞ –¥–ª—è z –∏–Ω–¥–µ–∫—Å–∞
                        const layerCreationComplete = new Event('layerCreationComplete');

const elements = [
  'UploadB', 'fillModeBtn',
  'brushSize', 'opacity', 'pressureBar', 'backgroundPicker',
  'addLayerBtn', 'removeLayerBtn', 'eraserBtn', 'layerButtons',
  'zoomBtn', 'canvasContainer', 'drawOnExistingBtn', 'identifyLayerBtn', 
  'layerOpacitySlider', 'layerOpacityValue', 'moveLayerUp',
  'moveLayerDown',
  'backgroundSettingsBtn',
  'backgroundSettingsModal',
  'closeModal',
  'backgroundColorPicker',
  'backgroundImageInput',
  'setBackgroundImageBtn'
];

const obj = Object.fromEntries(
  elements.map(id => [id, gel(id)])
);
const container = obj.canvasContainer;
                        const containerRect = container.getBoundingClientRect();
                        const layerPanel = document.querySelector('.layer-panel'),
                            sidebar = document.querySelector(".sidebar"),
                            layerOpacities = {},
                            layers = [],
                            contexts = {},
                            layerColors = [],
                            history = {},
                            points = [],
                            redoHistory = [];

                        const MAX_ZOOM = 100, MIN_ZOOM = 1, ZOOM_STEP = 0.02;

                        let layerCount = 0,
                            symmetry = true,
                            currentLayer = 1,
                            previousLayer = 1,

                            isSpider = false,

                            curCtx,
                            isDrawing = false,
                            isErasing = false,
                            isDrawOnExisting = false,
                            zoomLevel = 1, // 1000% = 10
                            isIdentifyingLayer = false,
                            wasDrawing = false,
                            isDraggingScroll = false,
                            startY,
                            currentCursor = 'auto',
                            isZoomActive = false,
                            offsetX = 0,
                            offsetY = 0,
                            lastX = null,
                            lastY = null,
                            uploadedImage = null,
                            clearedCanvasState = null,
                            isFillMode = false,
                            zoomOriginX = 0,
                            zoomOriginY = 0,
                            isSmoothLineMode = false,
                            isCtrlPressed = false;

                        const symmetryButton = gel('symmetry');

                        symmetryButton.addEventListener('click', toggleSymmetry);

                        const spiderButton = gel('spider');
                        spiderButton.addEventListener('click', toggleSpider);

                        // !
                        function toggleSymmetry() {
                            symmetry = !symmetry;
                            if (symmetry) {
                                symmetryButton.classList.add('active');
                            } else {
                                symmetryButton.classList.remove('active');
                            }
                        }

                        function toggleDrawOnExisting() {
                            isDrawOnExisting = !isDrawOnExisting;
                            drawOnExistingBtn.classList.toggle('active', isDrawOnExisting);
                        }
                        const spiderStrengthSlider = gel('spiderStrength');


                        function toggleSpider() {
                            isSpider = !isSpider;
                            spider.classList.toggle('active', isSpider);
                            // Show or hide the slider based on the spider tool state
                            spiderStrengthSlider.style.display = isSpider ? 'block' : 'none';
                        }


                    </script>
                    <script>

                        // document.dispatchEvent(layerCreationComplete);
                        drawOnExistingBtn.addEventListener('click', toggleDrawOnExisting);

                        // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø 
                        document.addEventListener('DOMContentLoaded', function () {

                            initializeApp();
                        });

                        function initializeApp() {
                            createLayer();
                        }

                        // —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –±—ç–∫–≥—Ä–∞—É–Ω–¥–∞
                        function setLayerBackground(layerIndex, imageUrl) {
                            const img = new Image();
                            img.onload = function () {
                                contexts[layerIndex].drawImage(img, 0, 0, layers[layerIndex].width, layers[layerIndex].height);
                            }
                            img.src = imageUrl;
                        }
                        // —Å–æ–∑–¥–∞–Ω–∏–µ —Å–ª–æ–µ–≤
                        function createLayer() {

                            updateZoom();
                            if (!layers[back]) {
                                const canvas = document.createElement('canvas');
                                canvas.width = 600;
                                canvas.height = 400;
                                canvas.style.position = 'absolute';
                                canvasContainer.appendChild(canvas);
                                layers[0] = canvas;
                                contexts[0] = canvas.getContext('2d', { willReadFrequently: true });
                                setLayerBackground(back, 'images/canvas1.jpg');
                            }

                            layerCount++;
                            layerColors[layerCount] = '#' + Math.floor(Math.random() * 16777215).toString(16);

                            const canvas = document.createElement('canvas');
                            canvas.id = `layer${layerCount}`;
                            canvas.width = realWidth;
                            canvas.height = realHeight;
                            canvas.style.width = `${displayWidth}px`;
                            canvas.style.height = `${displayHeight}px`;
                            canvas.style.position = 'absolute';
                            canvas.style.top = '0';
                            canvas.style.left = '0';
                            canvas.style.zIndex = layerCount;
                            canvasContainer.appendChild(canvas);
                            layers[layerCount] = canvas;
                            contexts[layerCount] = canvas.getContext('2d', { willReadFrequently: true });
                            const button = document.createElement('button');
                            button.textContent = " ‚ù§ ";
                            button.classList.add('layer-button');
                            button.dataset.layer = layerCount;


                            // Add eye icon
                            const eyeIcon = document.createElement('span');
                            eyeIcon.textContent = "üëÅÔ∏è";
                            eyeIcon.style.display = 'none';
                            eyeIcon.classList.add('eye-icon');
                            button.appendChild(eyeIcon);


                            layerButtons.appendChild(button);
                            button.addEventListener('click', function () {
                                setCurrentLayer(parseInt(this.dataset.layer));
                            });
                            addEventListenersToLayer(canvas);
                            setCurrentLayer(layerCount);
                            initializeLayer(layerCount);
                            history[layerCount] = [];
                            redoHistory[layerCount] = [];
                            updateLayerButtonColor(layerCount);
                            updateLayerOrder();
                            // createHistorySlider(layerCount);
                            layerDrawnOn[layerCount] = false; // Initialize as not drawn on

                        }


                        // button.addEventListener('click', function (event) {
                        //     setCurrentLayer(parseInt(this.dataset.layer));
                        //     showColorPicker(event);

                        //     addColorPickerToLayerButton(button);

                        // });

                        // —É—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç–µ–∫—É—â–µ–≥–æ —Å–ª–æ—è
                        function setCurrentLayer(layerNum) {
                            if (layerNum === back) {
                                return;
                            }

                            if (currentLayer !== layerNum) {
                                previousLayer = currentLayer;
                            }

                            currentLayer = layerNum;
                            curCtx = contexts[currentLayer];



                            const opacity = layerOpacities[layerNum] || 100;
                            layerOpacitySlider.value = opacity;
                            layerOpacityValue.textContent = opacity;
                            document.querySelectorAll('.layer-button').forEach(btn => {
                                btn.classList.remove('active-layer');
                                if (parseInt(btn.dataset.layer) === currentLayer) {
                                    btn.classList.add('active-layer');
                                }
                            });

                            // if (!isErasing) {
                            //     updateLayerButtonColor(layerNum);
                            // }

                            if (layerColors[layerNum]) {
                                curCtx.strokeStyle = layerColors[layerNum];
                            }
                            updateLayerEyeIcon(layerNum);
    // –î–æ–±–∞–≤—å—Ç–µ —ç—Ç–∏ —Å—Ç—Ä–æ–∫–∏ –≤ –∫–æ–Ω–µ—Ü —Ñ—É–Ω–∫—Ü–∏–∏:
    const outlineSize = outlineSizes[layerNum] || 0;
    outlineSizeInput.value = outlineSize;
    outlineSizeValue.textContent = outlineSize;
                        }
                        // –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞ —Å–ª–æ–µ–≤
                        function updateLayerButtonColor(layerNum) {
                            const button = document.querySelector(`.layer-button[data-layer="${layerNum}"]`);
                            if (button && layerColors[layerNum]) {
                                button.style.backgroundColor = layerColors[layerNum];
                            }
                        }
                        // –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–ª–æ—è(–Ω—É–∂–Ω–æ —Ç–∞–∫ –∂–µ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –Ω–æ–≤–æ–≥–æ —Å–ª–æ—è)
                        function initializeLayer(layerNum) {

                            contexts[layerNum].fillStyle = 'rgba(0,0,0,0)';
                            contexts[layerNum].fillRect(0, 0, layers[layerNum].width, layers[layerNum].height);
                        }

                        // —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ saveState
                        function saveState() {
                            if (!curCtx) return;

                            if (history[currentLayer].length >= MAX_HISTORY_STATES) {
                                history[currentLayer].shift();
                            }

                            history[currentLayer].push(curCtx.getImageData(0, 0, layers[currentLayer].width, layers[currentLayer].height));

                            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–ª–æ—è –æ–±–≤–æ–¥–∫–∏, –µ—Å–ª–∏ –æ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
                            if (outlineLayers[currentLayer]) {
                                const outlineLayerId = outlineLayers[currentLayer].id;
                                if (!history[outlineLayerId]) {
                                    history[outlineLayerId] = [];
                                }
                                if (history[outlineLayerId].length >= MAX_HISTORY_STATES) {
                                    history[outlineLayerId].shift();
                                }
                                history[outlineLayerId].push(contexts[outlineLayerId].getImageData(0, 0, layers[outlineLayerId].width, layers[outlineLayerId].height));
                            }

                            redoHistory[currentLayer] = [];

                            // –û—á–∏—â–∞–µ–º redo –∏—Å—Ç–æ—Ä–∏—é –¥–ª—è —Å–ª–æ—è –æ–±–≤–æ–¥–∫–∏
                            if (outlineLayers[currentLayer]) {
                                redoHistory[outlineLayers[currentLayer].id] = [];
                            }
                        }






                        function drawSpider(startX, startY, endX, endY, isSymmetric = false) {
                            curCtx.beginPath();
                            curCtx.moveTo(startX, startY);
                            curCtx.quadraticCurveTo(startX, startY, endX, endY);
                            curCtx.stroke();

                            const targetPoints = isSymmetric ? symmetricPoints : points;
                            targetPoints.push({ x: endX, y: endY });

                            var power = spiderStrengthSlider.value;

                            for (let i = 0; i < targetPoints.length; i++) {
                                const dx = targetPoints[i].x - endX;
                                const dy = targetPoints[i].y - endY;
                                const dd = dx * dx + dy * dy;
                                if (dd < power) {
                                    var mul = 0.1
                                    curCtx.beginPath();
                                    curCtx.moveTo(endX + (dx * mul), endY + (dy * mul));
                                    curCtx.lineTo(targetPoints[i].x - (dx * mul), targetPoints[i].y - (dy * mul));
                                    curCtx.stroke();
                                }
                            }
                        }
                        function startDrawing(e) {
                            if (currentLayer === 100 || !curCtx || isEyedropperActive || isCtrlPressed) {
                                return;
                            }
                            isDrawing = true;
                            const rect = layers[currentLayer].getBoundingClientRect();
                            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                            const x = Math.floor((clientX - rect.left) * (realWidth / displayWidth) / zoomLevel);
                            const y = Math.floor((clientY - rect.top) * (realHeight / displayHeight) / zoomLevel);

                            points.length = 0;
                            symmetricPoints.length = 0;
                            points.push({ x, y });

                            [lastX, lastY] = [x, y];
                            saveState();
                        }

                        function draw(e) {
                            if (!isDrawing || !curCtx) {
                                return;
                            }
                            if (isFinger) {
                                finger(e);
                                return;
                            }
                            if (!isDrawing || !curCtx) return;

                            const rect = layers[currentLayer].getBoundingClientRect();
                            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                            const x = Math.floor((clientX - rect.left) * (realWidth / displayWidth) / zoomLevel);
                            const y = Math.floor((clientY - rect.top) * (realHeight / displayHeight) / zoomLevel);

                            const pressure = e.pressure || 1;
                            curCtx.lineWidth = brushSize.value * pressure * (realWidth / displayWidth);
                            curCtx.lineCap = 'round';
                            curCtx.lineJoin = 'round';
                            curCtx.globalAlpha = opacity.value / 100;
                            curCtx.globalCompositeOperation = isErasing ? 'destination-out' : 'source-over';

                            if (isSpider) {
                                drawSpider(lastX, lastY, x, y, false);
                            } else {
                                if (isDrawOnExisting) {
                                    tools.drawOn(lastX, lastY, x, y, curCtx);
                                } else {
                                    curCtx.beginPath();
                                    curCtx.moveTo(lastX, lastY);
                                    curCtx.lineTo(x, y);
                                    curCtx.stroke();
                                }
                            }

                            if (symmetry) {
                                const centerX = realWidth / 2;
                                const symmetricLastX = centerX + (centerX - lastX);
                                const symmetricX = centerX + (centerX - x);

                                if (isSpider) {
                                    drawSpider(symmetricLastX, lastY, symmetricX, y, true);
                                } else {
                                    if (isDrawOnExisting) {
                                        tools.drawOn(symmetricLastX, lastY, symmetricX, y, curCtx);
                                    } else {
                                        curCtx.beginPath();
                                        curCtx.moveTo(symmetricLastX, lastY);
                                        curCtx.lineTo(symmetricX, y);
                                        curCtx.stroke();
                                    }
                                }
                            }

                            [lastX, lastY] = [x, y];
                            pressureBar.value = pressure * 10000;
                            pressureBar.nextElementSibling.textContent = Math.round(pressure * 100);
                            layerDrawnOn[currentLayer] = true;
                            updateLayerEyeIcon(currentLayer);
                        }
                        function changeResolution(newWidth, newHeight) {
                            realWidth = newWidth;
                            realHeight = newHeight;

                            Object.values(layers).forEach(layer => {
                                const tempCanvas = document.createElement('canvas');
                                tempCanvas.width = newWidth;
                                tempCanvas.height = newHeight;
                                const tempCtx = tempCanvas.getContext('2d');
                                tempCtx.drawImage(layer, 0, 0, layer.width, layer.height, 0, 0, newWidth, newHeight);

                                layer.width = newWidth;
                                layer.height = newHeight;
                                layer.getContext('2d').drawImage(tempCanvas, 0, 0);
                            });

                            updateCanvasScale();
                        }

                        // –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö
                        function updateResolutionSettings() {
                            const newWidth = gel('resolutionWidth').value;
                            const newHeight = gel('resolutionHeight').value;
                            changeResolution(newWidth, newHeight);
                        }

                        function getCanvasCoordinates(clientX, clientY) {
                            const rect = layers[currentLayer].getBoundingClientRect();
                            return {
                                x: (clientX - rect.left) / scale,
                                y: (clientY - rect.top) / scale
                            };
                        }

                        function stopDrawing() {
                            if (isDrawing) {
                                isDrawing = false;
                                saveState();
                                points.length = 0;
                                symmetricPoints.length = 0;
                            }
                            lastX = null;
                            lastY = null;
                        }

                        function endDrawing() {
                            if (isDrawing) {
                                isDrawing = false;
                                lastX = null;
                                lastY = null;
                            }
                        }

                        function addEventListenersToLayer(layer) {
                            // –≠—Ç–æ –º–µ—à–∞–ª–æ –Ω–∞–∂–∞—Ç–∏—è–º
                            // layer.addEventListener("touchstart", startDrawing);
                            // layer.addEventListener("touchmove", draw);
                            layer.addEventListener('pointerdown', startDrawing);
                            layer.addEventListener('pointermove', draw);
                            layer.addEventListener('pointerup', endDrawing);
                        }
                    </script>
                    <script>
                        // –ø–∏–ø–µ—Ç–∫–∞ 
                        canvasContainer.addEventListener('click', handleEyedropperClick);
                        canvasContainer.addEventListener('touchstart', handleEyedropperClick);

                        const eyedropperBtn = gel('eyedropperBtn');
                        let isEyedropperActive = false;

                        eyedropperBtn.addEventListener('click', handleEyedropperActivation);
                        eyedropperBtn.addEventListener('touchstart', handleEyedropperActivation);

                        function handleEyedropperActivation(e) {
                            e.preventDefault();

                            isEyedropperActive = !isEyedropperActive;
                            document.body.style.cursor = isEyedropperActive ? 'url(cursors/pipette.png), auto' : 'auto';
                            eyedropperBtn.classList.toggle('active');

                            if (isEyedropperActive) {
                                isDrawing = false;
                            }
                        }
function handleEyedropperClick(e) {
    if (!isEyedropperActive) return;

    e.preventDefault();

    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

    const rect = canvasContainer.getBoundingClientRect();
    const x = Math.floor((clientX - rect.left) * (realWidth / displayWidth) / zoomLevel);
    const y = Math.floor((clientY - rect.top) * (realHeight / displayHeight) / zoomLevel);

    const color = getPixelColor2(x, y);

    curCtx.strokeStyle = color;
    layerColors[currentLayer] = color;
    updateLayerButtonColor(currentLayer);

    const colorPicker = gel('colorPicker');
    if (colorPicker) {
        colorPicker.value = rgbToHex(color);
    }

    isEyedropperActive = false;
    document.body.style.cursor = 'auto';
    eyedropperBtn.classList.remove('active');
}

function getPixelColor2(x, y) {
    // Ensure x and y are integers
    x = Math.floor(x);
    y = Math.floor(y);

    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
    tempCanvas.width = realWidth;
    tempCanvas.height = realHeight;

    const sortedLayers = Object.entries(layers)
        .filter(([id]) => id !== back.toString())
        .sort((a, b) => parseInt(a[1].style.zIndex) - parseInt(b[1].style.zIndex));

    tempCtx.drawImage(layers[back], 0, 0, realWidth, realHeight);
    sortedLayers.forEach(([, layer]) => {
        tempCtx.drawImage(layer, 0, 0, realWidth, realHeight);
    });

    // Check if x and y are within the canvas bounds
    if (x < 0 || x >= realWidth || y < 0 || y >= realHeight) {
        console.warn(`Coordinates (${x}, ${y}) are out of bounds`);
        return 'rgba(0, 0, 0, 0)'; // Return transparent color for out-of-bounds pixels
    }

    const pixelData = tempCtx.getImageData(x, y, 1, 1).data;
    return `rgb(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]})`;
}



                        // –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å —Å–ª–æ–µ–≤
                        function togglePreviousLayer() {
                            [currentLayer, previousLayer] = [previousLayer, currentLayer];
                            const layerButton = document.querySelector(`.layer-button[data-layer="${currentLayer}"]`);
                            if (layerButton) {
                                layerButton.click();
                            }
                        }
                        const handlePointer = (e) => {
                          if (e.type === "pointerenter" || e.type === "pointerdown") {
                            e.preventDefault();
                            isDraggingScroll = true;
                            startY = e.clientY;
                          } else if (isDraggingScroll) {
                            const deltaY = e.clientY - startY;
                            (e.target === sidebar ? sidebar : layerPanel).scrollTop += deltaY;
                            startY = e.clientY;
                          }
                        };

                        const events = ["pointerenter", "pointerdown", "pointermove"];

                        [layerPanel, sidebar].forEach(element => {
                          events.forEach(event => element.addEventListener(event, handlePointer));
                        });

                        function updateLayerOrder() {
                            const layerButtons = Array.from(document.querySelectorAll('.layer-button'));
                            const baseZIndex = 110;

                            layerButtons.forEach((button, index) => {
                                const layerId = parseInt(button.dataset.layer);
                                if (layers[layerId]) {
                                    const zIndex = layerId === back ? -100 : baseZIndex + layerButtons.length - index;
                                    layers[layerId].style.zIndex = zIndex;

                                    if (outlineLayers[layerId]) {
                                        layers[outlineLayers[layerId].id].style.zIndex = zIndex + 1;
                                    }
                                }
                            });
                        }


                        function handleMoveLayerClick(event) {
                            const direction = event.target === moveLayerUp ? -1 : 1;
                            moveLayerInStack(direction);
                        }


                        moveLayerUp.addEventListener('click', () => {
                            moveLayerInStack(-1);
                        });
                        moveLayerDown.addEventListener('click', () => {
                            moveLayerInStack(1);
                        });
                        function moveLayerInStack(direction) {
                            const curLB = document.querySelector(`.layer-button[data-layer="${currentLayer}"]`);
                            const targetLayerButton = direction === -1
                                ? curLB.previousElementSibling
                                : curLB.nextElementSibling;

                            if (targetLayerButton) {
                                // –ü–µ—Ä–µ–º–µ—â–∞–µ–º –∫–Ω–æ–ø–∫—É —Å–ª–æ—è –≤ DOM
                                if (direction === -1) {
                                    curLB.parentNode.insertBefore(curLB, targetLayerButton);
                                } else {
                                    curLB.parentNode.insertBefore(targetLayerButton, curLB);
                                }

                                // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ—Ä—è–¥–æ–∫ —Å–ª–æ–µ–≤
                                updateLayerOrder();

                                // –ü–µ—Ä–µ–º–µ—â–∞–µ–º —Å–ª–æ–π –æ–±–≤–æ–¥–∫–∏ –≤–º–µ—Å—Ç–µ —Å –æ—Å–Ω–æ–≤–Ω—ã–º —Å–ª–æ–µ–º
                                if (outlineLayers[currentLayer]) {
                                    const outlineLayerId = outlineLayers[currentLayer].id;
                                    const outlineLayer = layers[outlineLayerId];
                                    const mainLayer = layers[currentLayer];
                                    outlineLayer.style.zIndex = parseInt(mainLayer.style.zIndex) + 1;
                                }

                                // –ê–∫—Ç–∏–≤–∏—Ä—É–µ–º –ø–µ—Ä–µ–º–µ—â–µ–Ω–Ω—ã–π —Å–ª–æ–π
                                curLB.click();
                            }

                        }
                        const layerButtonsContainer = gel('layerButtons');
                        // Zoom functions
                        document.addEventListener('keydown', (e) => {
                            if (e.key === 'Control') {
                                isCtrlPressed = true;
                            }
                            // fix
                            lastX = null;
                            lastY = null;
                        });

                        document.addEventListener('keyup', (e) => {
                            if (e.key === 'Control') {
                                isCtrlPressed = false;
                                // fix —Å–±—Ä—Ä–æ—Å
                                lastX = null;
                                lastY = null;
                            }
                        });



                        canvasContainer.addEventListener('mousemove', (e) => {
                            e.preventDefault();
                            if (isEyedropperActive || !isCtrlPressed || isDrawing || isFinger) return;



                            const rect = canvasContainer.getBoundingClientRect();
                            const mouseX = e.clientX - rect.left;
                            const mouseY = e.clientY - rect.top;

                            if (lastX !== undefined) {
                                const deltaX = e.movementX;
                                const oldZoom = zoomLevel;
                                zoomLevel = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, zoomLevel + deltaX * ZOOM_STEP));

                                if (oldZoom !== zoomLevel) {
                                    zoomOriginX = (mouseX - offsetX) / oldZoom;
                                    zoomOriginY = (mouseY - offsetY) / oldZoom;

                                    offsetX = mouseX - zoomOriginX * zoomLevel;
                                    offsetY = mouseY - zoomOriginY * zoomLevel;

                                    updateZoom();
                                }
                            }

                            lastX = mouseX;
                            lastY = mouseY;
                        });



                        function updateZoom() {
                            Object.values(layers).forEach(layer => {
                                layer.style.transformOrigin = '0 0';

                                if (zoomLevel <= 1) {
                                    offsetX = 0;
                                    offsetY = 0;
                                    layer.style.transform = `scale(${zoomLevel})`;
                                    layer.style.left = '0';
                                    layer.style.top = '0';
                                } else {
                                    layer.style.transform = `scale(${zoomLevel})`;

                                    const layerRect = layer.getBoundingClientRect();
                                    offsetX = Math.min(Math.max(offsetX, containerRect.width - layerRect.width), 0);
                                    offsetY = Math.min(Math.max(offsetY, containerRect.height - layerRect.height), 0);

                                    layer.style.left = `${offsetX}px`;
                                    layer.style.top = `${offsetY}px`;
                                }
                            });

                            canvasContainer.style.overflow = 'hidden';
                            gel('zoomLevelDisplay').textContent = `üîé${(zoomLevel * 100).toFixed(0)}%`;

                            // –û–±–Ω–æ–≤–ª—è–µ–º –æ–±–≤–æ–¥–∫—É –¥–ª—è –≤—Å–µ—Ö —Å–ª–æ–µ–≤
                            Object.keys(outlineLayers).forEach(layerNum => {
                                const size = outlineSizes[layerNum];
                                if (size > 0) {
                                    applyOutline(layerNum, size);
                                }
                            });
                        }

                        //  –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –ø–∞–ª–µ—Ü
                        let isFinger = false;

                        const fingerBtn = gel('fingerBtn');

                        fingerBtn.addEventListener('click', () => {
                            isFinger = !isFinger;
                            fingerBtn.classList.toggle('active', isFinger);
                        });
                        function finger(e) {

                            if (!isDrawing || !curCtx || !isFinger) return;

                            const rect = layers[currentLayer].getBoundingClientRect();
                            const x = Math.floor((e.clientX - rect.left) / zoomLevel);
                            const y = Math.floor((e.clientY - rect.top) / zoomLevel);

                            const brushSize = parseInt(brushSize.value);
                            const halfBrushSize = brushSize / 2;

                            curCtx.save();
                            curCtx.beginPath();
                            curCtx.arc(x, y, halfBrushSize, 0, Math.PI * 2);
                            curCtx.clip();

                            if (lastX !== null && lastY !== null) {
                                const dx = x - lastX;
                                const dy = y - lastY;
                                curCtx.drawImage(
                                    layers[currentLayer],
                                    x - halfBrushSize - dx, y - halfBrushSize - dy, brushSize, brushSize,
                                    x - halfBrushSize, y - halfBrushSize, brushSize, brushSize
                                );
                            }

                            curCtx.restore();

                            lastX = x;
                            lastY = y;
                        }
                        const MAX_HISTORY_STATES = 1000;

// –û–±–≤–æ–¥–∫–∞
                        const outlineLayers = {};
                        const outlineSizes = {};
                        let isInnerOutline = false;

                        // –ü–æ–ª—É—á–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã DOM
                        // –ü–æ–ª—É—á–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç DOM –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ü–≤–µ—Ç–∞ –æ–±–≤–æ–¥–∫–∏
                        const outlineColorPicker = gel('outlineColorPicker');

                        const toggleOutlineTypeBtn = gel('toggleOutlineTypeBtn');
                        const outlineSizeInput = gel('outlineSize');
                        const outlineSizeValue = gel('outlineSizeValue');

                        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è input —Ä–∞–∑–º–µ—Ä–∞ –æ–±–≤–æ–¥–∫–∏
                        outlineSizeInput.max = "20";

                        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –¥–ª—è –∫–Ω–æ–ø–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è —Ç–∏–ø–∞ –æ–±–≤–æ–¥–∫–∏
                        toggleOutlineTypeBtn.addEventListener('click', () => {
                            isInnerOutline = !isInnerOutline;
                            toggleOutlineTypeBtn.textContent = isInnerOutline ? 'üîΩ' : 'üîº';
                            applyOutline(currentLayer, parseInt(outlineSizeInput.value));
                        });

                        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–±—ã—Ç–∏—è –¥–ª—è input —Ä–∞–∑–º–µ—Ä–∞ –æ–±–≤–æ–¥–∫–∏
                        outlineSizeInput.addEventListener('input', function () {
                            const size = parseInt(this.value);
                            outlineSizeValue.textContent = size;
                            applyOutline(currentLayer, size);
                        });

                        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –æ–±–≤–æ–¥–∫–∏ –∫ —Å–ª–æ—é
function applyOutline(layerNum, size) {
    saveState();

    if (!layers[layerNum] || !contexts[layerNum]) {
        return;
    }

    let outlineLayerId = outlineLayers[layerNum] ? outlineLayers[layerNum].id : null;

    if (!outlineLayerId && size > 0) {
        outlineLayerId = createOutlineLayer(layerNum);
    }

    if (outlineLayerId) {
        const outlineCtx = contexts[outlineLayerId];
        const sourceCtx = contexts[layerNum];
        const canvas = layers[layerNum];

        outlineCtx.clearRect(0, 0, canvas.width, canvas.height);

        if (size > 0) {
            const scaledSize = size * (realWidth / displayWidth);
            const imageData = sourceCtx.getImageData(0, 0, realWidth, realHeight);
            const outlineImageData = outlineCtx.createImageData(realWidth, realHeight);

            requestAnimationFrame(() => {
                createOutline(imageData, outlineImageData, scaledSize, realWidth, realHeight, isInnerOutline);
                outlineCtx.putImageData(outlineImageData, 0, 0);
                outlineSizes[layerNum] = size;
                updateLayerList();
            });
        } else {
            // –ï—Å–ª–∏ —Ä–∞–∑–º–µ—Ä –æ–±–≤–æ–¥–∫–∏ 0, —É–¥–∞–ª—è–µ–º —Å–ª–æ–π –æ–±–≤–æ–¥–∫–∏
            canvasContainer.removeChild(layers[outlineLayerId]);
            delete layers[outlineLayerId];
            delete contexts[outlineLayerId];
            delete outlineLayers[layerNum];
            delete outlineSizes[layerNum];
        }
    }

    outlineSizes[layerNum] = size;
    updateLayerList();
}



                        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–ª–æ—è –æ–±–≤–æ–¥–∫–∏
                        function createOutlineLayer(layerNum) {
                            const outlineCanvas = document.createElement('canvas');
                            outlineCanvas.width = realWidth;
                            outlineCanvas.height = realHeight;
                            outlineCanvas.style.width = `${displayWidth}px`;
                            outlineCanvas.style.height = `${displayHeight}px`;
                            const outlineCtx = outlineCanvas.getContext('2d', { willReadFrequently: true });


                            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π –∏–Ω–¥–µ–∫—Å –¥–ª—è —Å–ª–æ—è –æ–±–≤–æ–¥–∫–∏
                            const newLayerIndex = Math.max(...Object.keys(layers).map(Number)) + 1;

                            // –î–æ–±–∞–≤–ª—è–µ–º —Å–ª–æ–π –æ–±–≤–æ–¥–∫–∏ –≤ —Å–ø–∏—Å–æ–∫ —Å–ª–æ–µ–≤ –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤
                            layers[newLayerIndex] = outlineCanvas;
                            contexts[newLayerIndex] = outlineCtx;

                            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–ª–æ–µ –æ–±–≤–æ–¥–∫–∏
                            outlineLayers[layerNum] = {
                                id: newLayerIndex,
                                canvas: outlineCanvas
                            };

                            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º z-index —Å–ª–æ—è –æ–±–≤–æ–¥–∫–∏ –≤—ã—à–µ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ —Å–ª–æ—è
                            outlineCanvas.style.zIndex = parseInt(layers[layerNum].style.zIndex) + 1;

                            // –í—Å—Ç–∞–≤–ª—è–µ–º —Å–ª–æ–π –æ–±–≤–æ–¥–∫–∏ –≤ DOM –ø–µ—Ä–µ–¥ –∏—Å—Ö–æ–¥–Ω—ã–º —Å–ª–æ–µ–º
                            canvasContainer.insertBefore(outlineCanvas, layers[layerNum].nextSibling);

                            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∏—Å—Ç–æ—Ä–∏—é –∏–∑–º–µ–Ω–µ–Ω–∏–π –¥–ª—è —Å–ª–æ—è –æ–±–≤–æ–¥–∫–∏
                            history[newLayerIndex] = [];
                            redoHistory[newLayerIndex] = [];
                            layerOpacities[newLayerIndex] = 100;

                            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏–Ω–¥–µ–∫—Å –Ω–æ–≤–æ–≥–æ —Å–ª–æ—è –æ–±–≤–æ–¥–∫–∏
                            return newLayerIndex;
                        }
                        function createOutline(sourceImageData, outlineImageData, size, width, height, isInner) {
                            const sourceData = sourceImageData.data;
                            const outlineData = outlineImageData.data;
                            const outlineColor = hexToRgb(outlineColorPicker.value);

                            for (let y = 0; y < height; y++) {
                                for (let x = 0; x < width; x++) {
                                    const index = (y * width + x) * 4;
                                    if ((isInner && sourceData[index + 3] > 0) || (!isInner && sourceData[index + 3] === 0)) {
                                        if (hasNeighborWithDifferentAlpha(sourceData, x, y, width, height, Math.ceil(size), isInner)) {
                                            outlineData.set(outlineColor, index);
                                        }
                                    }
                                }
                            }
                        }


                        function hasNeighborWithDifferentAlpha(sourceData, x, y, width, height, size, isInner) {
                            const targetAlpha = isInner ? 0 : 255;
                            for (let dy = -size; dy <= size; dy++) {
                                for (let dx = -size; dx <= size; dx++) {
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                        const neighborIndex = (ny * width + nx) * 4 + 3;
                                        if (sourceData[neighborIndex] === targetAlpha) {
                                            return true;
                                        }
                                    }
                                }
                            }
                            return false;
                        }


                        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ hex —Ü–≤–µ—Ç–∞ –≤ rgb –º–∞—Å—Å–∏–≤
                        function hexToRgb(hex) {
                            // –£–±–∏—Ä–∞–µ–º —Å–∏–º–≤–æ–ª # –≤ –Ω–∞—á–∞–ª–µ, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
                            hex = hex.replace('#', '');

                            // –ü–∞—Ä—Å–∏–º hex –∑–Ω–∞—á–µ–Ω–∏–µ –≤ rgb –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
                            const r = parseInt(hex.substring(0, 2), 16);
                            const g = parseInt(hex.substring(2, 4), 16);
                            const b = parseInt(hex.substring(4, 6), 16);

                            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –º–∞—Å—Å–∏–≤ [r, g, b]
                            return [r, g, b, 255]; // 255 –¥–ª—è alpha –∫–∞–Ω–∞–ª–∞
                        }

                        // –û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è —Å–ª–æ—è –≤ —Å—Ç–µ–∫–µ (–≤–≤–µ—Ä—Ö/–≤–Ω–∏–∑)
                        function moveLayerInStack(direction) {
                            const curLB = document.querySelector(`.layer-button[data-layer="${currentLayer}"]`);
                            const targetLayerButton = direction === -1 ? curLB.previousElementSibling : curLB.nextElementSibling;

                            if (targetLayerButton) {
                                // –ü–µ—Ä–µ–º–µ—â–∞–µ–º –∫–Ω–æ–ø–∫—É —Å–ª–æ—è –≤ DOM
                                if (direction === -1) {
                                    curLB.parentNode.insertBefore(curLB, targetLayerButton);
                                } else {
                                    curLB.parentNode.insertBefore(targetLayerButton, curLB);
                                }

                                // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ—Ä—è–¥–æ–∫ —Å–ª–æ–µ–≤
                                updateLayerOrder();

                                // –ü–µ—Ä–µ–º–µ—â–∞–µ–º —Å–ª–æ–π –æ–±–≤–æ–¥–∫–∏ –≤–º–µ—Å—Ç–µ —Å –æ—Å–Ω–æ–≤–Ω—ã–º —Å–ª–æ–µ–º
                                if (outlineLayers[currentLayer]) {
                                    const outlineLayerId = outlineLayers[currentLayer].id;
                                    const outlineLayer = layers[outlineLayerId];
                                    const mainLayer = layers[currentLayer];
                                    outlineLayer.style.zIndex = parseInt(mainLayer.style.zIndex) + 1;
                                }

                                // –ê–∫—Ç–∏–≤–∏—Ä—É–µ–º –ø–µ—Ä–µ–º–µ—â–µ–Ω–Ω—ã–π —Å–ª–æ–π
                                curLB.click();
                            }
                        }

                        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ—Ä—è–¥–∫–∞ —Å–ª–æ–µ–≤ –≤ DOM
                        function updateLayerOrder() {
                            const layerButtons = Array.from(document.querySelectorAll('.layer-button'));

                            layerButtons.forEach((button, index) => {
                                const layerId = parseInt(button.dataset.layer);

                                if (layers[layerId]) {
                                    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º z-index –¥–ª—è —Ñ–æ–Ω–æ–≤–æ–≥–æ —Å–ª–æ—è
                                    if (layerId === back) {
                                        layers[layerId].style.zIndex = -100;
                                    } else {
                                        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º z-index –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Å–ª–æ–µ–≤
                                        const zIndex = layerButtons.length - index + 110;
                                        layers[layerId].style.zIndex = zIndex;

                                        // –û–±–Ω–æ–≤–ª—è–µ–º z-index —Å–ª–æ—è –æ–±–≤–æ–¥–∫–∏, –µ—Å–ª–∏ –æ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
                                        if (outlineLayers[layerId]) {
                                            const outlineLayerId = outlineLayers[layerId].id;
                                            layers[outlineLayerId].style.zIndex = zIndex + 1;
                                        }
                                    }
                                }
                            });
                        }

                        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ —Å–ª–æ–µ–≤ –≤ –ø–∞–Ω–µ–ª–∏ —Å–ª–æ–µ–≤
                        function updateLayerList() {
                            const layerButtonsContainer = gel('layerButtons');
                            layerButtonsContainer.innerHTML = ''; // –û—á–∏—â–∞–µ–º —Ç–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ —Å–ª–æ–µ–≤

                            // –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Å–ª–æ–µ–≤, –∫—Ä–æ–º–µ —Ñ–æ–Ω–æ–≤–æ–≥–æ
                            const allLayers = Object.keys(layers).filter(id => id !== back.toString());

                            // –°–æ—Ä—Ç–∏—Ä—É–µ–º —Å–ª–æ–∏ –ø–æ z-index
                            allLayers.sort((a, b) => parseInt(layers[b].style.zIndex) - parseInt(layers[a].style.zIndex));

                            // –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–ª–æ—è
                            allLayers.forEach((layerId) => {
                                createLayerButton(layerId, layerButtonsContainer);
                            });

                            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ—Ä—è–¥–æ–∫ —Å–ª–æ–µ–≤ –≤ DOM
                            updateLayerOrder();

                            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–π —Å–ª–æ–π
                            const activeLayerButton = layerButtonsContainer.querySelector(`[data-layer="${currentLayer}"]`);
                            if (activeLayerButton) {
                                activeLayerButton.classList.add('active-layer');
                            }
                        }

                        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–Ω–æ–ø–∫–∏ —Å–ª–æ—è –≤ –ø–∞–Ω–µ–ª–∏ —Å–ª–æ–µ–≤
                        function createLayerButton(layerId, container) {
                            const button = document.createElement('button');
                            button.textContent = " ‚ù§ ";
                            button.classList.add('layer-button');
                            button.dataset.layer = layerId;

                            // –î–æ–±–∞–≤–ª—è–µ–º –∏–∫–æ–Ω–∫—É –≥–ª–∞–∑–∞
                            const eyeIcon = document.createElement('span');
                            eyeIcon.textContent = "üëÅÔ∏è";
                            eyeIcon.style.display = layerDrawnOn[layerId] ? 'inline' : 'none';
                            eyeIcon.classList.add('eye-icon');
                            button.appendChild(eyeIcon);

                            // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –Ω–∞ –∫–Ω–æ–ø–∫—É —Å–ª–æ—è
                            button.addEventListener('click', function () {
                                setCurrentLayer(parseInt(this.dataset.layer));
                            });

                            // –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É —Å–ª–æ—è –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
                            container.appendChild(button);

                            // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–≤–µ—Ç –∫–Ω–æ–ø–∫–∏ —Å–ª–æ—è
                            updateLayerButtonColor(layerId);
                        }


                    </script>
                    <script>
// Flood Fill Functionality // –∑–∞–ª–∏–≤–∫–∞
const floodFillBtn = gel('floodFillBtn');
let isFloodFillActive = false;

floodFillBtn.addEventListener('click', () => {
    isFloodFillActive = !isFloodFillActive;
    floodFillBtn.classList.toggle('active', isFloodFillActive);
});

// function floodFill(e) {
//     if (!isFloodFillActive || !curCtx) return;

//     const rect = layers[currentLayer].getBoundingClientRect();
//     const startX = Math.floor((e.clientX - rect.left) / zoomLevel);
//     const startY = Math.floor((e.clientY - rect.top) / zoomLevel);

//     console.log(`Flood fill starting at (${startX}, ${startY})`);

//     // –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –∫–∞–Ω–≤–∞—Å
//     const tempCanvas = document.createElement('canvas');
//     const tempCtx = tempCanvas.getContext('2d');
//     tempCanvas.width = realWidth;
//     tempCanvas.height = realHeight;

//     // –ö–æ–ø–∏—Ä—É–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤—Å–µ—Ö —Å–ª–æ–µ–≤ –Ω–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã–π –∫–∞–Ω–≤–∞—Å, –∏—Å–∫–ª—é—á–∞—è —Å–ª–æ–∏ 0, 1 –∏ —Ç–µ–∫—É—â–∏–π —Å–ª–æ–π
//     Object.entries(layers).forEach(([index, layer]) => {
//         if (index !== '0' && index !== '1' && index !== currentLayer.toString()) {
//             tempCtx.drawImage(layer, 0, 0);
//         }
//     });

//     const imageData = tempCtx.getImageData(0, 0, realWidth, realHeight);
//     const data = imageData.data;
//     const targetColor = getPixelColor(startX, startY, data, realWidth);
    
//     // Get the fill color from the current layer
//     const fillColor = layerColors[currentLayer] ? hexToRgba(layerColors[currentLayer]) : [0, 0, 0, 255]; // Default to black if no color found
//     const tolerance = 30;

//     // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ–≤–ø–∞–¥–∞–µ—Ç –ª–∏ —Ü–µ–ª–µ–≤–æ–π —Ü–≤–µ—Ç —Å —Ü–≤–µ—Ç–æ–º –∑–∞–ª–∏–≤–∫–∏
//     if (colorMatch(targetColor, fillColor, tolerance)) return;

//     const stack = [[startX, startY]];
//     const visited = new Uint8Array(realWidth * realHeight);

//     while (stack.length) {
//         const [x, y] = stack.pop();
//         const index = y * realWidth + x;
//         if (visited[index]) continue;
//         visited[index] = 1;

//         const pixelIndex = index * 4;
//         const currentColor = data.slice(pixelIndex, pixelIndex + 4);

//         // –ü–æ–∑–≤–æ–ª—è–µ–º –∑–∞–ª–∏–≤–∫—É, –µ—Å–ª–∏ —Ü–≤–µ—Ç —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å —Ü–µ–ª–µ–≤—ã–º –∏–ª–∏ —ç—Ç–æ —Å–ø–ª–æ—à–Ω–æ–π —Ü–≤–µ—Ç
//         if (colorMatch(currentColor, targetColor, tolerance) || isSolidColor(currentColor, tolerance)) {
//             setPixelColor(data, x, y, realWidth, fillColor);
//             if (x > 0 && !isContourPixel(x - 1, y, data, realWidth, realHeight, targetColor, tolerance)) stack.push([x - 1, y]);
//             if (x < realWidth - 1 && !isContourPixel(x + 1, y, data, realWidth, realHeight, targetColor, tolerance)) stack.push([x + 1, y]);
//             if (y > 0 && !isContourPixel(x, y - 1, data, realWidth, realHeight, targetColor, tolerance)) stack.push([x, y - 1]);
//             if (y < realHeight - 1 && !isContourPixel(x, y + 1, data, realWidth, realHeight, targetColor, tolerance)) stack.push([x, y + 1]);
//         }
//     }

//     curCtx.putImageData(imageData, 0, 0);
//     saveState();
//     layerDrawnOn[currentLayer] = true;
//     updateLayerEyeIcon(currentLayer);
// }

// // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ü–≤–µ—Ç —Å–ø–ª–æ—à–Ω—ã–º
// function isSolidColor(color, tolerance) {
//     return color[0] >= 255 - tolerance && color[1] >= 255 - tolerance && color[2] >= 255 - tolerance; // –ü—Ä–∏–º–µ—Ä –¥–ª—è –±–µ–ª–æ–≥–æ —Ü–≤–µ—Ç–∞
// }

// function isSolidColorArea(x, y, data, width, height, tolerance) {
//     const targetColor = getPixelColor(x, y, data, width);
//     const stack = [[x, y]];
//     const visited = new Set();

//     while (stack.length) {
//         const [currentX, currentY] = stack.pop();
//         const index = currentY * width + currentX;

//         if (visited.has(index)) continue;
//         visited.add(index);

//         const currentColor = getPixelColor(currentX, currentY, data, width);
//         if (!colorMatch(currentColor, targetColor, tolerance)) continue;

//         // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å–µ–¥–Ω–∏–µ –ø–∏–∫—Å–µ–ª–∏
//         if (currentX > 0) stack.push([currentX - 1, currentY]);
//         if (currentX < width - 1) stack.push([currentX + 1, currentY]);
//         if (currentY > 0) stack.push([currentX, currentY - 1]);
//         if (currentY < height - 1) stack.push([currentX, currentY + 1]);
//     }

//     return visited.size > 5; // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –Ω–∞–π–¥–µ–Ω–æ –±–æ–ª—å—à–µ 5 –ø–∏–∫—Å–µ–ª–µ–π
// }
// function isContourPixel(x, y, data, width, height, targetColor, tolerance) {
//     const currentColor = getPixelColor(x, y, data, width);
//     return !colorMatch(currentColor, targetColor, tolerance);
// }

// function setPixelColor(data, x, y, width, color) {
//     const index = (y * width + x) * 4;
//     data[index] = color[0];
//     data[index + 1] = color[1];
//     data[index + 2] = color[2];
//     data[index + 3] = color[3];
// }

// function shouldFillPixel(x, y, data, width, height, fillColor) {
//     const directions = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];
//     let filledNeighbors = 0;
//     for (const [dx, dy] of directions) {
//         const nx = x + dx;
//         const ny = y + dy;
//         if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
//             const neighborColor = getPixelColor(nx, ny, data, width);
//             if (colorMatch(neighborColor, fillColor, 0)) {
//                 filledNeighbors++;
//             }
//         }
//     }
//     return filledNeighbors >= 5;
// }

// function hexToRgba(hex) {
//     const r = parseInt(hex.slice(1, 3), 16);
//     const g = parseInt(hex.slice(3, 5), 16);
//     const b = parseInt(hex.slice(5, 7), 16);
//     return [r, g, b, 255];
// }

// function colorMatch(a, b, tolerance) {
//     return Math.abs(a[0] - b[0]) <= tolerance &&
//            Math.abs(a[1] - b[1]) <= tolerance &&
//            Math.abs(a[2] - b[2]) <= tolerance &&
//            (a.length < 4 || b.length < 4 || Math.abs(a[3] - b[3]) <= tolerance);
// }

// function getPixelColor(x, y, data, width) {
//     x = Math.floor(x);
//     y = Math.floor(y);
//     if (x < 0 || x >= width || y < 0 || y >= data.length / 4 / width) {
//         return [0, 0, 0, 0]; // Return transparent color for out-of-bounds pixels
//     }
//     const index = (y * width + x) * 4;
//     return [data[index], data[index + 1], data[index + 2], data[index + 3]];
// }

// function rgbToHex(rgb) {
//     const [r, g, b] = rgb.match(/\d+/g);
//     return "#" + ((1 << 24) + (parseInt(r) << 16) + (parseInt(g) << 8) + parseInt(b)).toString(16).slice(1);
// }

// // Add event listener for canvasContainer
// canvasContainer.addEventListener('click', (e) => {
//     if (isFloodFillActive) {
//         floodFill(e);
//     }
// });

function floodFill(e) {
    if (!isFloodFillActive || !curCtx) return;

    const rect = layers[currentLayer].getBoundingClientRect();
    const startX = Math.floor((e.clientX - rect.left) / zoomLevel);
    const startY = Math.floor((e.clientY - rect.top) / zoomLevel);

    console.log(`Flood fill starting at (${startX}, ${startY})`);

    // –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –∫–∞–Ω–≤–∞—Å
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = realWidth;
    tempCanvas.height = realHeight;

    // –ö–æ–ø–∏—Ä—É–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤—Å–µ—Ö —Å–ª–æ–µ–≤ –Ω–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã–π –∫–∞–Ω–≤–∞—Å, –∏—Å–∫–ª—é—á–∞—è —Å–ª–æ–∏ 0, 1 –∏ —Ç–µ–∫—É—â–∏–π —Å–ª–æ–π
    Object.entries(layers).forEach(([index, layer]) => {
        if (index !== '0' && index !== '1' && index !== currentLayer.toString()) {
            tempCtx.drawImage(layer, 0, 0);
        }
    });

    const imageData = tempCtx.getImageData(0, 0, realWidth, realHeight);
    const data = imageData.data;
    const targetColor = getPixelColor(startX, startY, data, realWidth);
    
    // Get the fill color from the current layer
    const fillColor = layerColors[currentLayer] ? hexToRgba(layerColors[currentLayer]) : [0, 0, 0, 255]; // Default to black if no color found
    const tolerance = 30;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ–≤–ø–∞–¥–∞–µ—Ç –ª–∏ —Ü–µ–ª–µ–≤–æ–π —Ü–≤–µ—Ç —Å —Ü–≤–µ—Ç–æ–º –∑–∞–ª–∏–≤–∫–∏
    if (colorMatch(targetColor, fillColor, tolerance)) return;

    const stack = [[startX, startY]];
    const visited = new Uint8Array(realWidth * realHeight);

    while (stack.length) {
        const [x, y] = stack.pop();
        const index = y * realWidth + x;
        if (visited[index]) continue;
        visited[index] = 1;

        const pixelIndex = index * 4;
        const currentColor = data.slice(pixelIndex, pixelIndex + 4);

        // –ü–æ–∑–≤–æ–ª—è–µ–º –∑–∞–ª–∏–≤–∫—É, –µ—Å–ª–∏ —Ü–≤–µ—Ç —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å —Ü–µ–ª–µ–≤—ã–º –∏–ª–∏ —ç—Ç–æ —Å–ø–ª–æ—à–Ω–æ–π —Ü–≤–µ—Ç
        if (colorMatch(currentColor, targetColor, tolerance) || isSolidColor(currentColor, tolerance)) {
            setPixelColor(data, x, y, realWidth, fillColor);
            if (x > 0 && !isContourPixel(x - 1, y, data, realWidth, realHeight, targetColor, tolerance)) stack.push([x - 1, y]);
            if (x < realWidth - 1 && !isContourPixel(x + 1, y, data, realWidth, realHeight, targetColor, tolerance)) stack.push([x + 1, y]);
            if (y > 0 && !isContourPixel(x, y - 1, data, realWidth, realHeight, targetColor, tolerance)) stack.push([x, y - 1]);
            if (y < realHeight - 1 && !isContourPixel(x, y + 1, data, realWidth, realHeight, targetColor, tolerance)) stack.push([x, y + 1]);
        }
    }

    curCtx.putImageData(imageData, 0, 0);
    saveState();
    layerDrawnOn[currentLayer] = true;
    updateLayerEyeIcon(currentLayer);
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ü–≤–µ—Ç —Å–ø–ª–æ—à–Ω—ã–º
function isSolidColor(color, tolerance) {
    return color[0] >= 255 - tolerance && color[1] >= 255 - tolerance && color[2] >= 255 - tolerance; // –ü—Ä–∏–º–µ—Ä –¥–ª—è –±–µ–ª–æ–≥–æ —Ü–≤–µ—Ç–∞
}

function isContourPixel(x, y, data, width, height, targetColor, tolerance) {
    const currentColor = getPixelColor(x, y, data, width);
    return !colorMatch(currentColor, targetColor, tolerance);
}

function setPixelColor(data, x, y, width, color) {
    const index = (y * width + x) * 4;
    data[index] = color[0];
    data[index + 1] = color[1];
    data[index + 2] = color[2];
    data[index + 3] = color[3];
}

function hexToRgba(hex) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b, 255];
}

function colorMatch(a, b, tolerance) {
    return Math.abs(a[0] - b[0]) <= tolerance &&
           Math.abs(a[1] - b[1]) <= tolerance &&
           Math.abs(a[2] - b[2]) <= tolerance &&
           (a.length < 4 || b.length < 4 || Math.abs(a[3] - b[3]) <= tolerance);
}

function getPixelColor(x, y, data, width) {
    x = Math.floor(x);
    y = Math.floor(y);
    if (x < 0 || x >= width || y < 0 || y >= data.length / 4 / width) {
        return [0, 0, 0, 0]; // Return transparent color for out-of-bounds pixels
    }
    const index = (y * width + x) * 4;
    return [data[index], data[index + 1], data[index + 2], data[index + 3]];
}

// Add event listener for canvasContainer
canvasContainer.addEventListener('click', (e) => {
    if (isFloodFillActive) {
        floodFill(e);
    }
});


</script>

                    <script>
                        // –¥–æ–±–∞–≤–ª—è–µ–º –∏–∫–æ–Ω–∫—É –∑–∞–¥–µ–π—Å—Ç–≤–æ–≤–∞–Ω–Ω—ã—Ö —Å–ª–æ–µ–≤
                        const layerDrawnOn = {};
                        function updateLayerEyeIcon(layerNum) {
                            const layerButton = document.querySelector(`.layer-button[data-layer="${layerNum}"]`);
                            if (layerButton) {
                                const eyeIcon = layerButton.querySelector('.eye-icon');
                                if (eyeIcon) {
                                    eyeIcon.style.display = layerDrawnOn[layerNum] ? 'inline' : 'none';
                                }
                            }
                        }
// —Å–æ–æ–±—â–µ–Ω–∏–µ
                        // const messageButton = gel('message');
                        // const messageContainer = gel('message-container');
                        // const messageText = gel('message-text');

                        // function showMessage(message) {
                        //     messageText.textContent = message;
                        //     messageContainer.style.display = 'block';
                        // }

                        // messageButton.addEventListener('click', () => {
                        //     showMessage("–ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ."); // Show a test message
                        // });

                        // if (!messageContainer.querySelector('.close-button')) {
                        //     const closeButton = document.createElement('span');
                        //     closeButton.textContent = '√ó';
                        //     closeButton.classList.add('close-button');
                        //     messageContainer.appendChild(closeButton);

                        //     closeButton.addEventListener('click', () => {
                        //         messageContainer.style.display = 'none';
                        //     });
                        // }

                        // window.addEventListener('click', (event) => {
                        //     if (event.target === messageContainer) {
                        //         messageContainer.style.display = 'none';
                        //     }
                        // });

                    </script>
<script>
    // const messageButton = gel('message');
    // const messageContainer = gel('message-container');
    // const messageText = gel('message-text');
    // function showMessage(message) {
    //     messageText.innerHTML = `<pre>${message}</pre>`; // –ò—Å–ø–æ–ª—å–∑—É–µ–º <pre> –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
    //     messageContainer.style.display = 'block';
    // }

    // messageButton.addEventListener('click', () => {
    //     fetch('message.txt')
    //         .then(response => {
    //             if (!response.ok) {
    //                 throw new Error(`Network response was not ok: ${response.status} ${response.statusText}`);
    //             }
    //             return response.text();
    //         })
    //         .then(data => {
    //             showMessage(data); // –ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ —Ñ–∞–π–ª–∞
    //         })
    //         .catch(error => {
    //             console.error('There was a problem with the fetch operation:', error);
    //             showMessage(`–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: ${error.message}`); // –ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
    //         });
    // });

    // if (!messageContainer.querySelector('.close-button')) {
    //     const closeButton = document.createElement('span');
    //     closeButton.textContent = '√ó';
    //     closeButton.classList.add('close-button');
    //     messageContainer.appendChild(closeButton);

    //     closeButton.addEventListener('click', () => {
    //         messageContainer.style.display = 'none';
    //     });
    // }

    // window.addEventListener('click', (event) => {
    //     if (event.target === messageContainer) {
    //         messageContainer.style.display = 'none';
    //     }
    // });
$(document).ready(function() {
    const messageButton = $('#message');
    const messageContainer = $('#message-container');
    const messageText = $('#message-text');

    function showMessage(message) {
        messageText.html(`<pre>${message}</pre>`); // –ò—Å–ø–æ–ª—å–∑—É–µ–º <pre> –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        messageContainer.show();
    }

    messageButton.on('click', function() {
        if (messageContainer.is(':visible')) {
            messageContainer.hide(); // –°–∫—Ä—ã—Ç—å –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä, –µ—Å–ª–∏ –æ–Ω —É–∂–µ –æ—Ç–∫—Ä—ã—Ç
        } else {
            fetch('message.txt')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Network response was not ok: ${response.status} ${response.statusText}`);
                    }
                    return response.text();
                })
                .then(data => {
                    showMessage(data); // –ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ —Ñ–∞–π–ª–∞
                })
                .catch(error => {
                    showMessage(`–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: ${error.message}`); // –ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
                });
        }
    });

    if (!messageContainer.find('.close-button').length) {
        const closeButton = $('<span class="close-button">√ó</span>');
        messageContainer.append(closeButton);

        closeButton.on('click', function() {
            messageContainer.hide();
        });
    }

    $(window).on('click', function(event) {
        if ($(event.target).is(messageContainer)) {
            messageContainer.hide();
        }
    });
});
// —Å–æ–∑–¥–∞–Ω–∏–µ —Å–ª–æ–µ–≤
    document.addEventListener('DOMContentLoaded', () => {
                    for (let i = 1; i < 100; i++) {
                        createLayer();
                        setCurrentLayer(50);
                        const layerButtonsContainer = document.querySelector('.layer-panel');
                        layerButtonsContainer.scrollTop = (layerButtonsContainer.scrollHeight / 120) * 50;
                    }
                });
</script>
                    </script>
                    <script src="script.js" defer></script>
                    <script src="cursors.js" defer></script>
                    <script type="module" src="constants.js" defer></script>
                    <script type="module" src="main.js" defer></script>
                    <script type="module" src="settings.js" defer></script>
                    <script type="module" src="helperFunction.js" defer></script>
                    <script type="module" src="listners.js" defer></script>
                    <script type="module" src="hotkey.js" defer></script>
                    <script type="module" src="settingsPanel.js" defer></script>
                    <script type="module" src="tools.js" defer></script>

</body>

</html>