<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ù–∞—Å—Ç–æ—è—â–∏–π –•—É–¥–æ–∂–Ω–∏–∫</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jscolor/2.4.5/jscolor.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
    <script type="module" src="tools.js" defer></script>
    <style>
        .word-navigation {
            display: flex;
            align-items: center;
            z-index: 10;
        }

        .layer-panel {
            /* gap: 50px; */
            max-height: 600px;
            overflow-y: auto;
        }

        .layer-button {
            color: transparent;
            /*—Ü–≤–µ—Ç —Å–µ—Ä–¥—Ü–∞*/
            font-size: 10px;
            flex-direction: column;
            display: flex;
 
            /* padding: 50px; */
            cursor: pointer;
            border-radius: 20%;
        }
  
        .layer-button.active-layer {
color:transparent;
        height: 50px;;
    /* border: none;  */

        }


        body {
            cursor: url('cursors/pencil.png'), auto;
        }

        .color-picker-group-two input[type="color"] {
            appearance: none;
            /* -webkit-appearance: none;    */
            border: none;
            width: 20px;
            /* –£–≤–µ–ª–∏—á–∏–º —Ä–∞–∑–º–µ—Ä –¥–ª—è –ª—É—á—à–µ–π –≤–∏–¥–∏–º–æ—Å—Ç–∏ */
            height: 20px;
            /* padding: 0; */
            cursor: pointer;
        }

        .color-picker-group-two input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-picker-group-two input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 0;
            /* –£–±–∏—Ä–∞–µ–º —Å–∫—Ä—É–≥–ª–µ–Ω–∏–µ —É–≥–ª–æ–≤ */
        }

        /* –î–ª—è Firefox */
        .color-picker-group-two input[type="color"]::-moz-color-swatch {
            border: none;
            border-radius: 0;
        }


#floodFillBtn.active { 
  background-color: lightblue; /* Example: Change background color when active */
  /* Add any other styles you want for the active state */
}

img{
  /* transform: scale(1.1); */
  border-radius: 100px;
}


img:hover {
  transform: scale(1.01);
  box-shadow: 
    0px 0px 100px rgba(23, 201, 0, 0.5), /* Outer shadow (green) */
    inset 0px 0px 150px rgba(23, 201, 0, 0.5); /* Inner shadow (black) */
  border-radius: 100px;
}


.icon-hover:hover {
  transform: scale(1.31);
  box-shadow: 
    0px 0px 100px rgba(23, 201, 0, 0.5), /* Outer shadow (green) */
    inset 0px 0px 150px rgba(23, 201, 0, 0.5); /* Inner shadow (green) */
  border-radius: 100px; 
}

.icon-hover { /* Styles applied in the normal state */
  /* transform: scale(1.01); */
  box-shadow: 
    0px 0px 100px rgba(225, 0, 255, 0.201), /* Outer shadow (green) */
    inset 0px 0px 150px rgba(255, 0, 255, 0.217); /* Inner shadow (green) */
  border-radius: 100px; 
} 

    </style>
</head>

<body>
    <div class="base-container">
        <div class="sidebar">
            <a href="index.html" target="_self" title="–í—ã–π—Ç–∏ –∏–∑ –∫–æ–º–∞–Ω—Ç—ã" id="exitLink">üö™</a>
            <button id="message" title="–°–æ–æ–±—â–µ–Ω–∏–µ">‚úâÔ∏è</button>
            <div id="message-container" style="display: none;">
                <p id="message"></p>
            </div>
            <button id="identifyLayerBtn" title="–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å–ª–æ–π">üîç</button>
            <input type="file" id="imageInput" accept="image/*" style="display: none;">
            <button id="UploadButton" title="–ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (U)">üå∫</button>
            <button id="saveImageBtn" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ">üé¨</button>
            <button id="eraserBtn">üßΩ</button>
            <button id="changeCursorBtn" title="–°–º–µ–Ω–∏—Ç—å –∫—É—Ä—Å–æ—Ä">üé®</button>
            <button id="undoBtn" title="–û—Ç–º–µ–Ω–∏—Ç—å (Z)">‚ü≤</button>
            <button id="redoBtn" title="–ü–æ–≤—Ç–æ—Ä–∏—Ç—å (X)">‚ü≥</button>
            <button id="clear" title="–û—á–∏—Å—Ç–∏—Ç—å">üíÄ</button>

            <button id="fillModeBtn" title="–ó–∞–ª–∏–≤–∫–∞ (F)">üåä</button>
            <button id="floodFillBtn" title="–ó–∞–ª–∏—Ç—å —Ü–≤–µ—Ç–æ–º">‚ú®</button>
            <button id="eyedropperBtn" title="–ü–∏–ø–µ—Ç–∫–∞ –∑–∞–ª–∏–≤–∫–∏ (A)">üíß</button>
            <button id="brushEyedropperBtn" title="–ü–∏–ø–µ—Ç–∫–∞ –∫–∏—Å—Ç–∏ (D)">üñåÔ∏è</button>
            <div id="cursorPanel" class="cursor-panel" style="display: none;">
                <h3>–í—ã–±–µ—Ä–∏—Ç–µ –∫—É—Ä—Å–æ—Ä</h3>
                <div id="cursorList"></div>
            </div>
            <button id="settings" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏">‚öôÔ∏è</button>
        </div>
        <div class="canvas-and-sliders">
            <div class="layer-panel">
                <div id="layerButtons"></div>
            </div>
            <div class="canvas-container">
                <div class="color-picker-and-word">
                    <div class="color-picker-group">
                        <input type="color" id="colorPicker" value="#000000" title="–¶–≤–µ—Ç –∑–∞–ª–∏–≤–∫–∏ (C)">
                        <input type="color" id="colorPicker2" value="#ffffff" title="–±—É–ª—ã–π">
                        <input type="color" id="colorPicker3" value="#ff0000" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 3">
                        <input type="color" id="colorPicker4" value="#ffa500" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 4">
                        <input type="color" id="colorPicker5" value="#ffff00" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 5">
                        <input type="color" id="colorPicker6" value="#008000" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 6">
                        <input type="color" id="colorPicker7" value="#00ffff" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 7">
                        <input type="color" id="colorPicker8" value="#0000ff" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 8">
                        <input type="color" id="colorPicker9" value="#800080" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 9">
                        <div class="color-picker-group-two">
                            <input type="color" id="backgroundPicker" value="#ffffff" title="–¶–≤–µ—Ç —Ñ–æ–Ω–∞ (B)">
            <button id="symmetry" title="–°–∏–º–º–µ—Ç—Ä–∏—è (S)">ü¶ã</button>
                        </div>

                    </div>
                    <div class="word-navigation">
                        <button id="previousWord" title="–ü—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–ª–æ–≤–æ">&lt;</button>
                        <p id="Quizz"></p>
                        <button id="nextWord" title="–°–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ">&gt;</button>
                    </div>
                    <div class="header-container">
                        <div class="time-wrapper">
                            <span id="time" class="time"></span>
                            <span id="startTime" class="time"></span>
                            <span id="elapsedTime" class="time"></span>
                        </div>
                    </div>
                </div>
                <div class="canv-container" id="canvasContainer">
                </div>
                <div class="slider-group">
                    <div class="tools-column">
                        <label for="opacity" title="–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å">üëª</label>
                        <input type="range" id="opacity" min="1" max="100" value="100">
                        <span id="opacityValue" style="color: red;">100</span>

                    </div>
                    <div class="tools-column">
                        <label for="brushSize" title="–†–∞–∑–º–µ—Ä –∫–∏—Å—Ç–∏">üñåÔ∏è</label>
                        <input type="range" id="brushSize" min="1" max="300" value="3">
                        <span id="brushSizeValue" style="color: red;">3</span>

                    </div>
                    <div class="tools-column">
                        <div class="pressure-bar-container">
                            <label for="pressureBar" title="–ù–∞–∂–∏–º">üéØ</label>
                            <progress id="pressureBar" value="0" max="4000"></progress>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    </div>
    </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            for (let i = 2; i < 100; i++) {
                createLayer();
                setCurrentLayer(50);
                const layerButtonsContainer = document.querySelector('.layer-panel');
                layerButtonsContainer.scrollTop = (layerButtonsContainer.scrollHeight / 120) * 50;
            }
        });

        document.addEventListener('contextmenu', event => event.preventDefault());

        // Initialize layers and contexts
        const layers = {};
        const contexts = {};
        const layerColors = {}; // Example: { 1: '#000000', 2: '#ff0000', ... }
        let currentLayer = 1;
        let currentCtx;
        let layerCount = 0;

        // Initialize other variables
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let symmetry = false;
        let isErasing = false;

        // Get DOM elements
        const brushSizeInput = document.getElementById('brushSize');
        const opacityInput = document.getElementById('opacity');
        const pressureBar = document.getElementById('pressureBar');

        const backgroundPicker = document.getElementById('backgroundPicker');
        const canvasContainer = document.getElementById('canvasContainer');
        const layerButtons = document.getElementById('layerButtons');
        const addLayerBtn = document.getElementById('addLayerBtn');
        const removeLayerBtn = document.getElementById('removeLayerBtn');

        const eraserBtn = document.getElementById('eraserBtn');
        eraserBtn.addEventListener('click', toggleEraser);

        const isPressureSupported = 'onpointermove' in window;

        let history = {};
        let redoHistory = {};
        let previousLayer = 1;

        function createLayer() {
            layerCount++;

            layerColors[layerCount] = '#' + Math.floor(Math.random() * 16777215).toString(16);

            const canvas = document.createElement('canvas');
            canvas.id = `layer${layerCount}`;
            if (layerCount === 1) {
                canvas.style.visibility = 'hidden'; // Hide the first layer
            }
            canvas.width = 700;
            canvas.height = 500;
            canvas.style.position = 'absolute';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.zIndex = layerCount;


            canvasContainer.appendChild(canvas);

            layers[layerCount] = canvas;
            contexts[layerCount] = canvas.getContext('2d');

            const button = document.createElement('button');
            button.textContent = " ‚ù§ ";// add –∑–∞–º–µ–Ω–∏–ª —Ç—É—Ç –±—ã–ª–æ layerCount

            button.classList.add('layer-button');
            button.dataset.layer = layerCount;
            layerButtons.appendChild(button);

            button.addEventListener('click', function () {
                setCurrentLayer(parseInt(this.dataset.layer));
            });

            addEventListenersToLayer(canvas);
            setCurrentLayer(layerCount);
            initializeLayer(layerCount);

            // Initialize history for the new layer
            history[layerCount] = [];
            redoHistory[layerCount] = [];

            // Set initial button color
            updateLayerButtonColor(layerCount);
        }

        function setCurrentLayer(layerNum) {
            // Update previousLayer ONLY if the layer is actually changing
            if (currentLayer !== layerNum) {
                previousLayer = currentLayer;
            }

            currentLayer = layerNum;
            currentCtx = contexts[currentLayer];

            document.querySelectorAll('.layer-button').forEach(btn => {
                btn.classList.remove('active-layer');
                if (parseInt(btn.dataset.layer) === currentLayer) {
                    btn.classList.add('active-layer');
                }
            });

            console.log('Switched to layer:', currentLayer, 'Context:', currentCtx);

            // Update button colors when switching layers
            if (!isErasing) {
                updateLayerButtonColor(layerNum);
            }

            if (layerColors[layerNum]) {
                currentCtx.strokeStyle = layerColors[layerNum];
            }
        }





        function updateLayerButtonColor(layerNum) {
            const button = document.querySelector(`.layer-button[data-layer="${layerNum}"]`);
            if (button && layerColors[layerNum]) {
                button.style.backgroundColor = layerColors[layerNum];
            }
        }

        // !!!??? –ø–æ—á–µ–º—É —Ç—É—Ç 1 –ª–µ–µ—Ä —É–∫–∞–∑–∞–Ω –Ω–µ –ø–æ–π–º—É.
        function initializeLayer(layerNum) {
            if (layerNum === 0) {
                contexts[layerNum].fillStyle = '#' + Math.floor(Math.random() * 16777215).toString(16);
            } else {
                contexts[layerNum].fillStyle = 'rgba(0,0,0,0)'; // Transparent
            }
            contexts[layerNum].fillRect(0, 0, layers[layerNum].width, layers[layerNum].height);
        }

        function saveState() {
            if (!currentCtx) {
                console.error('–æ—à–∏–±–∫–∞ –≤ —Ñ—É–Ω–∫—Ü–∏–∏ saveState', currentLayer);
                return;
            }
            history[currentLayer].push(currentCtx.getImageData(0, 0, layers[currentLayer].width, layers[currentLayer].height));
            redoHistory[currentLayer] = [];
        }


        // function saveState() {
        //     if (!currentCtx) {
        //         console.error('–æ—à–∏–±–∫–∞ –≤ —Ñ—É–Ω–∫—Ü–∏–∏ saveState', currentLayer);
        //         return;
        //     }

        //     const currentState = currentCtx.getImageData(0, 0, layers[currentLayer].width, layers[currentLayer].height);
        //     history[currentLayer].push(currentState);
        //     redoHistory[currentLayer] = []; // –û—á–∏—â–∞–µ–º redo –∏—Å—Ç–æ—Ä–∏—é –ø—Ä–∏ –Ω–æ–≤–æ–º –¥–µ–π—Å—Ç–≤–∏–∏

        //     console.log('State saved for layer:', currentLayer);
        // }


        function startDrawing(e) {
            if (!currentCtx) {
                console.error('Error: currentCtx is undefined in startDrawing.', currentLayer);
                return;
            }
            isDrawing = true;
            const rect = layers[currentLayer].getBoundingClientRect();
            [lastX, lastY] = [e.clientX - rect.left, e.clientY - rect.top];

            // Save the state before starting to draw
            saveState();
        }

        function draw(e) {
            if (!isDrawing || !currentCtx) {
                if (!currentCtx) {
                    console.error('Error: currentCtx is undefined in draw. Current layer:', currentLayer);
                }
                return;
            }
            e.preventDefault();
            const rect = layers[currentLayer].getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const pressure = e.pressure || 1;

            currentCtx.lineWidth = brushSizeInput.value * pressure;
            currentCtx.lineCap = 'round';
            currentCtx.lineJoin = 'round';
            currentCtx.globalAlpha = opacityInput.value / 100;

            if (isErasing) {
                currentCtx.globalCompositeOperation = 'destination-out';
            } else {
                currentCtx.globalCompositeOperation = 'source-over';
            }

            currentCtx.beginPath();
            currentCtx.moveTo(lastX, lastY);
            currentCtx.lineTo(x, y);
            currentCtx.stroke();

            if (symmetry) {
                const centerX = layers[currentLayer].width / 2;
                const symmetricLastX = centerX + (centerX - lastX);
                const symmetricX = centerX + (centerX - x);
                currentCtx.beginPath();
                currentCtx.moveTo(symmetricLastX, lastY);
                currentCtx.lineTo(symmetricX, y);
                currentCtx.stroke();
            }

            [lastX, lastY] = [x, y];

            if (isPressureSupported) {
                console.log(pressure)
                pressureBar.value = pressure * 10000;
            }
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
            }
        }

        const colorPickers = document.querySelectorAll('input[type="color"]');
        colorPickers.forEach((picker, index) => {
            picker.addEventListener('input', (event) => {
                setDrawingColor(event.target.value);
            });
            // –ù–∞–∑–Ω–∞—á–∞–µ–º –≥–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ü–≤–µ—Ç–æ–≤
            document.addEventListener('keydown', (e) => {
                if (e.key === (index + 1).toString()) {
                    setDrawingColor(picker.value);
                }
            });
        });

        document.addEventListener('touchstart', function (e) {
            if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') {
                e.preventDefault();
            }
        }, { passive: false });

        function addEventListenersToLayer(layer) {
            layer.addEventListener('pointerdown', startDrawing);
            layer.addEventListener('pointermove', draw);
            layer.addEventListener('pointerup', stopDrawing);
            layer.addEventListener('pointerout', stopDrawing);
            layer.addEventListener('pointercancel', stopDrawing);
        }

        document.querySelectorAll('button, input').forEach(element => {
            element.addEventListener('pointerdown', (e) => {
                e.stopPropagation();
            });
        });
        function clearCanvas() {
            if (!currentCtx) return;

            // Save the current state before clearing
            saveState();

            // Clear only the current layer's canvas
            currentCtx.clearRect(0, 0, layers[currentLayer].width, layers[currentLayer].height);

            // If it's the background layer (layer 1), fill it with the background color
            if (currentLayer === 1) {
                currentCtx.fillStyle = backgroundPicker.value;
                currentCtx.fillRect(0, 0, layers[currentLayer].width, layers[currentLayer].height);
            }

            // Save the cleared state
            saveState();
        }


        // Initialize the first layer
        createLayer();


        // –î–æ–±–∞–≤–ª—è–µ–º —Å–ª—É—à–∞—Ç–µ–ª–∏ —Å–æ–±—ã—Ç–∏–π –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º —Å–ª–æ—è–º
        Object.values(layers).forEach(addEventListenersToLayer);


        function toggleEraser() {
            isErasing = !isErasing;
            eraserBtn.classList.toggle('active', isErasing);
            // Change the cursor to indicate eraser mode
            if (isErasing) {
                document.body.style.cursor = 'url(cursors/eraser.png), auto'; // Assuming you have an eraser cursor image
            } else {
                document.body.style.cursor = 'default';
            }
        }

        // document.getElementById('undoBtn').addEventListener('click', undo);
        // document.getElementById('redoBtn').addEventListener('click', redo);


        function togglePreviousLayer() {
            // Swap currentLayer and previousLayer
            [currentLayer, previousLayer] = [previousLayer, currentLayer];

            // Simulate a click on the corresponding layer button
            const layerButton = document.querySelector(`.layer-button[data-layer="${currentLayer}"]`);
            if (layerButton) {
                layerButton.click(); // This will trigger the button's click event
            }
        }

        function redrawCanvas() {
            currentCtx.fillStyle = backgroundPicker.value;
            currentCtx.fillRect(0, 0, layer2.width, layer2.height);
            if (uploadedImage) {
                currentCtx.drawImage(uploadedImage, 0, 0, layer2.width, layer2.height);
            }
        }
        function setBackground() {
            if (contexts[1]) {
                contexts[1].fillStyle = backgroundPicker.value;
                contexts[1].fillRect(0, 0, layers[1].width, layers[1].height);
                saveState();
            }
        }

        // –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Å–ª–æ–µ–≤
        let isIdentifyingLayer = false;
        let wasDrawing = false;  // Moved `wasDrawing` to global scope

        const identifyLayerBtn = document.getElementById('identifyLayerBtn');

        // Add a single click event listener to the canvas container

        // Canvas container click event to identify layers
        canvasContainer.addEventListener('click', (e) => {
            if (isIdentifyingLayer) {
                identifyLayerClickHandler(e);

                // Reset cursor and drawing state AFTER layer identification
                canvasContainer.style.cursor = 'default';
                isDrawing = wasDrawing;  // Restore drawing state

                // Deactivate layer identification mode
                isIdentifyingLayer = false;
                identifyLayerBtn.classList.remove('active');
            }
        });

        // Button click event to toggle layer identification mode
        identifyLayerBtn.addEventListener('click', () => {


            if (isIdentifyingLayer) {
                // Temporarily disable drawing when identifying the layer
                wasDrawing = isDrawing;  // Save current drawing state
                isDrawing = false;

                canvasContainer.style.cursor = 'crosshair';
            } else {
                // Restore default cursor when exiting identification mode
                canvasContainer.style.cursor = 'default';
                isDrawing = wasDrawing;  // Restore drawing state
            }
        });

        // Handler to identify the clicked layer
        function identifyLayerClickHandler(e) {

            isIdentifyingLayer = !isIdentifyingLayer;

            identifyLayerBtn.classList.toggle('active', isIdentifyingLayer);
            const rect = layers[1].getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            for (let i = layerCount; i >= 1; i--) {
                const ctx = contexts[i];
                const pixelData = ctx.getImageData(x, y, 1, 1).data;

                if (pixelData[3] > 0) {  // Alpha value > 0 means something is drawn
                    setCurrentLayer(i);
                    console.log('Found drawing on layer:', i);
                    updateLayerButtonColor(i);
                    break;  // Exit the loop after finding the top-most layer
                }
            }
        }


const layerPanel = document.querySelector('.layer-panel');

let isDraggingScroll = false;
let startY;

layerPanel.addEventListener('pointerdown', (e) => {
    e.preventDefault(); // Prevents drawing from interfering with scrolling
    isDraggingScroll = true;
    startY = e.clientY;
});

layerPanel.addEventListener('pointermove', (e) => {
    if (isDraggingScroll) {
        const deltaY = e.clientY - startY;
        layerPanel.scrollTop += deltaY;
        startY = e.clientY;
    }
});

layerPanel.addEventListener('pointerup', () => {
    isDraggingScroll = false;
});












// // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –¥–µ–π—Å—Ç–≤–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
// function preventDefaultAction(event) {
//   event.preventDefault();
//   event.stopPropagation();
//   return false;
// }

// // –ü–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ —Å–æ–±—ã—Ç–∏—è keydown
// document.addEventListener('keydown', function(event) {
//   // –†–∞–∑—Ä–µ—à–∞–µ–º —Ç–æ–ª—å–∫–æ F12
//   if (event.key !== 'F12') {
//     return preventDefaultAction(event);
//   }
// }, true);

// // –ü–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ —Å–æ–±—ã—Ç–∏—è keyup
// document.addEventListener('keyup', function(event) {
//   // –†–∞–∑—Ä–µ—à–∞–µ–º —Ç–æ–ª—å–∫–æ F12
//   if (event.key !== 'F12') {
//     return preventDefaultAction(event);
//   }
// }, true);

// // –ü–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ —Å–æ–±—ã—Ç–∏—è keypress
// document.addEventListener('keypress', function(event) {
//   // –†–∞–∑—Ä–µ—à–∞–µ–º —Ç–æ–ª—å–∫–æ F12
//   if (event.key !== 'F12') {
//     return preventDefaultAction(event);
//   }
// }, true);

// // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º beforeunload –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã
// window.addEventListener('beforeunload', function(event) {
//   event.preventDefault();
//   event.returnValue = '';
// });

// // –ü–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º contextmenu –¥–ª—è –æ—Ç–∫–ª—é—á–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –º–µ–Ω—é
// document.addEventListener('contextmenu', function(event) {
//   event.preventDefault();
// });


// –í —Ñ–∞–π–ª–µ main.js, –ø–æ—Å–ª–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–Ω–æ–ø–æ–∫ —Å–ª–æ—ë–≤

// –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∫–Ω–æ–ø–æ–∫ —Å–ª–æ—ë–≤
const layerButtonsContainer = document.getElementById('layerButtons');

// –î–µ–ª–∞–µ–º –∫–Ω–æ–ø–∫–∏ —Å–ª–æ—ë–≤ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º—ã–º–∏
$(function() {
  $(layerButtonsContainer).sortable({
    // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ—Ä—è–¥–æ–∫ —Å–ª–æ—ë–≤ –ø–æ—Å–ª–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
    update: function(event, ui) {
      updateLayerOrder();
    }
  });
  $(layerButtonsContainer).disableSelection();
});

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ—Ä—è–¥–∫–∞ —Å–ª–æ—ë–≤
function updateLayerOrder() {
  // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∫–Ω–æ–ø–∫–∏ —Å–ª–æ—ë–≤ –≤ –Ω–æ–≤–æ–º –ø–æ—Ä—è–¥–∫–µ
  const layerButtons = layerButtonsContainer.querySelectorAll('.layer-button');

  // –û–±–Ω–æ–≤–ª—è–µ–º z-index –∫–∞–∂–¥–æ–≥–æ —Å–ª–æ—è –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å –Ω–æ–≤—ã–º –ø–æ—Ä—è–¥–∫–æ–º –∫–Ω–æ–ø–æ–∫
  layerButtons.forEach((button, index) => {
    const layerId = `layer${button.dataset.layer}`;
    const canvas = document.getElementById(layerId);
    canvas.style.zIndex = index + 1; // z-index –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å 1
  });
}


// Flood Fill Functionality
function floodFill(e) {
  if (!currentCtx) {
    console.error('Error: currentCtx is undefined in floodFill. Current layer:', currentLayer);
    return;
  }

  const startX = e.offsetX;
  const startY = e.offsetY;
  const imageData = currentCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height); // Use drawingCanvas
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;

  const targetColor = getPixelColor(data, startX, startY, width);
  const fillColor = hexToRgba(colorPicker.value);
  const tolerance = 30;

  if (colorMatch(targetColor, fillColor, tolerance)) return;

  const stack = [[startX, startY]];
  const visited = new Uint8Array(width * height);

  while (stack.length) {
    const [x, y] = stack.pop();
    const index = y * width + x;

    if (visited[index]) continue;
    visited[index] = 1;

    const pixelIndex = index * 4;
    const currentColor = data.slice(pixelIndex, pixelIndex + 4);

    if (colorMatch(currentColor, targetColor, tolerance) || isContourPixel(x, y, data, width, height, targetColor, tolerance)) {
      setPixelColor(data, x, y, width, fillColor);

      if (x > 0) stack.push([x - 1, y]);
      if (x < width - 1) stack.push([x + 1, y]);
      if (y > 0) stack.push([x, y - 1]);
      if (y < height - 1) stack.push([x, y + 1]);
    }
  }

  // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–æ—Ö–æ–¥
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const index = (y * width + x) * 4;
      if (!colorMatch(data.slice(index, index + 4), fillColor, 0) && shouldFillPixel(x, y, data, width, height, fillColor)) {
        setPixelColor(data, x, y, width, fillColor);
      }
    }
  }

  currentCtx.putImageData(imageData, 0, 0);
  saveState();
}

// ... (rest of your flood fill helper functions) ...

// Modify the event listener for floodFill 
// drawingCanvas.addEventListener('click', (e) => { // Use drawingCanvas here
//   if (isFillMode) {
//     floodFill(e);
//   }
// });

// ... (your existing code) ...

const floodFillBtn = document.getElementById('floodFillBtn'); 
let isFloodFillActive = false; // –§–ª–∞–≥ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –∑–∞–ª–∏–≤–∫–∏


floodFillBtn.addEventListener('click', () => {
  isFloodFillActive = !isFloodFillActive; 
  floodFillBtn.classList.toggle('active', isFloodFillActive);

  // ... your other logic ...
});

floodFillBtn.addEventListener('click', () => {
  isFloodFillActive = !isFloodFillActive; 

  // –ò–∑–º–µ–Ω–µ–Ω–∏–µ –≤–Ω–µ—à–Ω–µ–≥–æ –≤–∏–¥–∞ –∫–Ω–æ–ø–∫–∏, —á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å –∞–∫—Ç–∏–≤–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
  floodFillBtn.classList.toggle('active', isFloodFillActive);

  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –≤—ã —Ö–æ—Ç–∏—Ç–µ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ø—Ä–∏ –≤–∫–ª—é—á–µ–Ω–∏–∏/–≤—ã–∫–ª—é—á–µ–Ω–∏–∏ –∑–∞–ª–∏–≤–∫–∏
  if (isFloodFillActive) {
    console.log('Flood Fill mode is ON');
    // ... 
  } else {
    console.log('Flood Fill mode is OFF');
    // ... 
  }
});

// –¥–æ–±–∞–≤–ª—è–µ–º –∫–ª–∞—Å—Å –¥–ª—è –∫—Ä–∞—Å–∏–≤—ã—Ö –∏–∫–æ–Ω–æ–∫
document.addEventListener('DOMContentLoaded', () => {
  // Select all icon elements. 
  // Modify this selector to accurately target your icons if needed.
  const icons = document.querySelectorAll('a, button'); 

  // Add the class to each icon
  icons.forEach(icon => {
    icon.classList.add('icon-hover');
  });
});

    </script>
    <script src="cursors.js" defer></script>
    <script src="script.js" defer></script>
    <script type="module" src="main.js" defer></script>
    <script type="module" src="hotkey.js" defer></script>
    <script type="module" src="test.js" defer></script>
    <script type="module" src="settings.js" defer></script>
    <script type="module" src="helperFunction.js" defer></script>
    <script type="module" src="tools.js" defer></script>

    <script type="module" src="buttons.js" defer></script>

</body>

</html>