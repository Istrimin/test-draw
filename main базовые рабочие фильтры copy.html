<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–ù–∞—Å—Ç–æ—è—â–∏–π –•—É–¥–æ–∂–Ω–∏–∫</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jscolor/2.4.5/jscolor.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
</head>

<body>
    <div class="base-container">
        <div class="sidebar">
            <a href="index.html" target="_self" title="–í—ã–π—Ç–∏ –∏–∑ –∫–æ–º–∞–Ω—Ç—ã" id="exitLink">üö™</a>
            <button id="message" title="–°–æ–æ–±—â–µ–Ω–∏–µ">‚úâÔ∏è</button>
            <div id="message-container" class="message-popup">
                <p id="message-text"></p>
            </div>
            <button id="mergeDownBtn" title="–°–ª–∏—Ç—å co —Å–ª–æ–µ–º –Ω–∏–∂–µ">üîΩ</button>
            <button id="backgroundSettingsBtn" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ñ–æ–Ω–∞">üñºÔ∏è</button>
            <button id="canvasSettingsBtn" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–∞–Ω–≤–∞—Å–∞">üñåÔ∏è</button>
            <button id="fullscreenBtn" title="–ü–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π —Ä–µ–∂–∏–º">üî≤</button>
            <button id="spider" title="–ü–∞—É—Ç–∏–Ω–∫–∞">üï∑Ô∏è</button>
            <button id="fingerBtn" title="–°—É–∂–µ–Ω–∏–µ –∫ —Ü–µ–Ω—Ç—Ä—É">üéØ</button>
            <button id="identifyLayerBtn" title="–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å–ª–æ–π">üîç</button>
            <button id="drawOnExistingBtn" title="–†–∏—Å–æ–≤–∞—Ç—å –Ω–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–º">‚û°Ô∏è</button>
            <input type="file" id="imageInput" accept="image/*" style="display: none;">
            <button id="UploadB" title="–ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (U)">üå∫</button>
            <button id="saveImageBtn" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ">üé¨</button>
            <button id="eraserBtn">üßΩ</button>
            <button id="changeCursorBtn" title="–°–º–µ–Ω–∏—Ç—å –∫—É—Ä—Å–æ—Ä">üé®</button>
            <button id="undoBtn" title="–û—Ç–º–µ–Ω–∏—Ç—å (Z)">‚ü≤</button>
            <button id="redoBtn" title="–ü–æ–≤—Ç–æ—Ä–∏—Ç—å (X)">‚ü≥</button>
            <button id="clear" title="–û—á–∏—Å—Ç–∏—Ç—å">üíÄ</button>
            <button id="fillModeBtn" title="–ó–∞–ª–∏–≤–∫–∞ (F)">üåä</button>
            <button id="floodFillBtn" title="–ó–∞–ª–∏—Ç—å —Ü–≤–µ—Ç–æ–º">‚ú®</button>
            <button id="eyedropperBtn" title="–ü–∏–ø–µ—Ç–∫–∞ –∑–∞–ª–∏–≤–∫–∏ (A)">üíß</button>
            <button id="deleteAllBtn" title="–£–¥–∞–ª–∏—Ç—å –≤—Å–µ">üóëÔ∏è</button>
            <button id="mergeLayers" title="–û–±—ä–µ–¥–∏–Ω–∏—Ç—å —Å–ª–æ–∏">üîó</button>
            <button id="settings" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏">‚öôÔ∏è</button>
        </div>
        <div id="colorPreview"></div>
        <div class="canvas-and-sliders">
            <div class="layer-panel-wrapper">
                <button id="moveLayerUp" title="–°–ª–æ–π –≤–≤–µ—Ä—Ö">‚ñ≤</button>
                <div class="layer-panel">
                    <div id="layerButtons"></div>
                </div>
                <button id="moveLayerDown" title="–°–ª–æ–π –≤–Ω–∏–∑">‚ñº</button>
            </div>
            <div class="canvas-container">
                <div class="color-picker-and-word">
                    <div class="color-picker-group">
                        <input type="color" id="colorPicker" value="#000000" title="–¶–≤–µ—Ç –∑–∞–ª–∏–≤–∫–∏ (C)">
                        <input type="color" id="colorPicker2" value="#ffffff" title="–±—É–ª—ã–π">
                        <input type="color" id="colorPicker3" value="#ff0000" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 3">
                        <input type="color" id="colorPicker4" value="#ffa500" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 4">
                        <input type="color" id="colorPicker5" value="#ffff00" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 5">
                        <input type="color" id="colorPicker6" value="#008000" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 6">
                        <input type="color" id="colorPicker7" value="#00ffff" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 7">
                        <input type="color" id="colorPicker8" value="#0000ff" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 8">
                        <input type="color" id="colorPicker9" value="#800080" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 9">
                        <input type="color" id="backgroundPicker" value="#ffffff" title="–¶–≤–µ—Ç —Ñ–æ–Ω–∞ (B)">
                        <div class="color-picker-group-two">
                        </div>
                        <button id="symmetry" title="–°–∏–º–º–µ—Ç—Ä–∏—è (S)">ü¶ã</button>
                    </div>
                    <div class="word-navigation">
                        <button id="previousWord" title="–ü—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–ª–æ–≤–æ">&lt;</button>
                        <p id="Quizz"></p>
                        <button id="nextWord" title="–°–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ">&gt;</button>
                    </div>
                    <div class="header-container">
                        <div class="time-wrapper">
                            <span id="time" class="time"></span>
                            <span id="startTime" class="time"></span>
                            <span id="elapsedTime" class="time"></span>
                            <button id="zoomBtn" title="–õ—É–ø–∞"></button>
                            <div id="zoomLevelDisplay" title="–£—Ä–æ–≤–µ–Ω—å –∑—É–º–∞"></div>
                        </div>
                    </div>
                </div>
                <div class="canv-container" id="canvasContainer">
                    <div id="cursorPanel" class="cursor-panel" style="display: none;">
                        <h3>–í—ã–±–µ—Ä–∏—Ç–µ –∫—É—Ä—Å–æ—Ä</h3>
                        <div id="cursorList"></div>
                    </div>
                </div>
                <div class="sliders">
                    <label for="spiderStrength" title="–°–∏–ª–∞ –ø–∞—É–∫–∞" style="display: none;">üï∏Ô∏è</label>
                    <input type="range" id="spiderStrength" min="50" max="10000" value="1000" title="–°–∏–ª–∞ –ø–∞—É–∫–∞"
                        style="display: none;">
                </div>
                <div class="sliders">
                    <label for="opacity" title="–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å">üëª</label>
                    <input type="range" id="opacity" min="1" max="100" value="100">
                    <span id="opacityValue" style="color: red;">100</span>
                    <label for="layerOpacitySlider" title="–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å —Å–ª–æ—è">üëì</label>
                    <input type="range" id="layerOpacitySlider" min="0" max="100" value="100">
                    <span id="layerOpacityValue" style="color: red;">100</span>
                </div>
                <div class="sliders">
                    <label for="brushSize" title="–†–∞–∑–º–µ—Ä –∫–∏—Å—Ç–∏">üñåÔ∏è</label>
                    <input type="range" id="brushSize" min="1" max="300" value="3">
                    <span id="brushSizeValue" style="color: red;">3</span>
                        <div class="sliders">

                    <div class="pressure-bar-container">
                        <label for="pressureBar" title="–ù–∞–∂–∏–º">üéØ</label>
                        <progress id="pressureBar" value="0" max="4000"></progress>
                        <span id="pressureValue" class="pressure-value"></span>
                        </div>                        </div>
                            <label for="outlineSize" title="–†–∞–∑–º–µ—Ä –æ–±–≤–æ–¥–∫–∏">üñºÔ∏è</label>
                    <span style="font-size: 1.5em;">&#8690;</span>
                            <input type="range" id="outlineSize" min="0" max="20" value="0">
                            <span id="outlineSizeValue" style="color: red;">0</span>
                            <button id="toggleOutlineTypeBtn" title="–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Ç–∏–ø –æ–±–≤–æ–¥–∫–∏">üîÑ</button>
                            <input type="color" id="outlineColorPicker" value="#000000" title="–¶–≤–µ—Ç –æ–±–≤–æ–¥–∫–∏">
                            <button id="applyOutlineBtn" title="–ü—Ä–∏–º–µ–Ω–∏—Ç—å –æ–±–≤–æ–¥–∫—É">‚úÖ</button>
                        </div>
                        <div class="filter-sliders">
                            <label for="lightnessSlider" title="–°–≤–µ—Ç–ª–æ—Å—Ç—å">üåë</label>
                            <input type="range" id="lightnessSlider" min="0" max="100" value="100">
                            <span id="lightnessValue" style="color: red;">100</span>
                            <label for="saturationSlider" title="–¶–≤–µ—Ç–Ω–æ—Å—Ç—å">üé®</label>
                            <input type="range" id="saturationSlider" min="0" max="200" value="100">
                            <span id="saturationValue" style="color: red;">200</span>
                            <label for="contrastSlider" title="–ö–æ–Ω—Ç—Ä–∞—Å—Ç">üîÜ</label>
                            <input type="range" id="contrastSlider" min="0" max="1000" value="100">
                            <span id="contrastValue" style="color: red;">200</span>
                            <label for="hueShiftSlider" title="–¶–≤–µ—Ç–æ–≤–æ–π —Å–¥–≤–∏–≥">üåà</label>
                            <input type="range" id="hueShiftSlider" min="0" max="360" value="0">
                            <span id="hueShiftValue" style="color: red;">0</span>
                        </div>
                        <div id="backgroundSettingsModal" class="modal">
                            <div class="modal-content">
                                <span id="closeModal" style="float:right;cursor:pointer;">&times;</span>
                                <input type="color" id="backgroundColorPicker" value="#ffffff">
                                <br><br>
                                <input type="file" id="backgroundImageInput" accept="image/*" multiple>
                                <div id="backgroundImageGallery"
                                    style="display: flex; flex-wrap: wrap; margin-top: 10px;"></div>
                                <div id="backgroundPreview"
                                    style="display: none; position: absolute; z-index: 1000; border: 2px solid #000;">
                                </div>
                            </div>
                            <!-- Canvas Settings Modal -->
                            <div id="canvasSettingsModal" class="modal">
                                <div class="modal-content">
                                    <span id="closeCanvasModal" style="float:right;cursor:pointer;">&times;</span>
                                    <input type="color" id="canvasColorPicker" value="#00">
                                    <br><br>
                                    <input type="file" id="canvasImageInput" accept="image/*">
                                    <div id="canvasImageGallery"
                                        style="display: flex; flex-wrap: wrap; margin-top: 10px;"></div>
                                </div>
                            </div>
                            <script>

                                const layerFilters = {};

                                const mergeDownBtn = document.getElementById('mergeDownBtn');

                                mergeDownBtn.addEventListener('click', mergeLayerDown);

                                function mergeLayerDown() {
                                    const currentLayerIndex = parseInt(currentLayer);
                                    const layerBelow = findLayerBelow(currentLayerIndex);

                                    if (layerBelow === null) {
                                        showMessage("–ù–µ—Ç —Å–ª–æ—è –Ω–∏–∂–µ –¥–ª—è —Å–ª–∏—è–Ω–∏—è.");
                                        return;
                                    }

                                    // –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π canvas –¥–ª—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è —Å–ª–æ–µ–≤
                                    const tempCanvas = document.createElement('canvas');
                                    tempCanvas.width = layers[currentLayer].width;
                                    tempCanvas.height = layers[currentLayer].height;
                                    const tempCtx = tempCanvas.getContext('2d');

                                    // –†–∏—Å—É–µ–º –Ω–∏–∂–Ω–∏–π —Å–ª–æ–π
                                    tempCtx.drawImage(layers[layerBelow], 0, 0);

                                    // –†–∏—Å—É–µ–º —Ç–µ–∫—É—â–∏–π —Å–ª–æ–π –ø–æ–≤–µ—Ä—Ö
                                    tempCtx.globalAlpha = layerOpacities[currentLayer] / 100;
                                    tempCtx.drawImage(layers[currentLayer], 0, 0);

                                    // –û—á–∏—â–∞–µ–º –Ω–∏–∂–Ω–∏–π —Å–ª–æ–π –∏ –∫–æ–ø–∏—Ä—É–µ–º –Ω–∞ –Ω–µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                                    contexts[layerBelow].clearRect(0, 0, layers[layerBelow].width, layers[layerBelow].height);
                                    contexts[layerBelow].drawImage(tempCanvas, 0, 0);

                                    // –£–¥–∞–ª—è–µ–º —Ç–µ–∫—É—â–∏–π —Å–ª–æ–π
                                    deleteLayer(currentLayerIndex);

                                    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∏–∂–Ω–∏–π —Å–ª–æ–π –∫–∞–∫ —Ç–µ–∫—É—â–∏–π
                                    setCurrentLayer(layerBelow);

                                    // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–ª–æ–µ–≤
                                    updateLayerList();
                                    showMessage("–°–ª–æ–∏ –æ–±—ä–µ–¥–∏–Ω–µ–Ω—ã.");
                                }

                                function findLayerBelow(currentLayerIndex) {
                                    const layerIds = Object.keys(layers)
                                        .filter(id => id !== back.toString())
                                        .sort((a, b) => parseInt(layers[b].style.zIndex) - parseInt(layers[a].style.zIndex));

                                    const currentLayerPosition = layerIds.indexOf(currentLayerIndex.toString());
                                    if (currentLayerPosition < layerIds.length - 1) {
                                        return parseInt(layerIds[currentLayerPosition + 1]);
                                    }
                                    return null;
                                }

                                function deleteLayer(layerId) {
                                    // –£–¥–∞–ª—è–µ–º canvas —Å–ª–æ—è
                                    layers[layerId].remove();

                                    // –£–¥–∞–ª—è–µ–º —Å–ª–æ–π –∏–∑ –≤—Å–µ—Ö –æ–±—ä–µ–∫—Ç–æ–≤
                                    delete layers[layerId];
                                    delete contexts[layerId];
                                    delete layerColors[layerId];
                                    delete layerOpacities[layerId];
                                    delete history[layerId];
                                    delete redoHistory[layerId];

                                    // –£–¥–∞–ª—è–µ–º –∫–Ω–æ–ø–∫—É —Å–ª–æ—è
                                    const layerButton = document.querySelector(`.layer-button[data-layer="${layerId}"]`);
                                    if (layerButton) {
                                        layerButton.remove();
                                    }

                                    // –ï—Å–ª–∏ —É —Å–ª–æ—è –±—ã–ª–∞ –æ–±–≤–æ–¥–∫–∞, —É–¥–∞–ª—è–µ–º –∏ –µ–µ
                                    if (outlineLayers[layerId]) {
                                        const outlineLayerId = outlineLayers[layerId].id;
                                        layers[outlineLayerId].remove();
                                        delete layers[outlineLayerId];
                                        delete contexts[outlineLayerId];
                                        delete outlineLayers[layerId];
                                    }
                                }
                            </script>
                            <script>const lightnessSlider = document.getElementById('lightnessSlider');
                                const saturationSlider = document.getElementById('saturationSlider');
                                const contrastSlider = document.getElementById('contrastSlider');
                                const lightnessValue = document.getElementById('lightnessValue');
                                const saturationValue = document.getElementById('saturationValue');
                                const contrastValue = document.getElementById('contrastValue');
                                const hueShiftSlider = document.getElementById('hueShiftSlider');
                                const hueShiftValue = document.getElementById('hueShiftValue');

                                hueShiftSlider.addEventListener('input', updateFilters);
                                lightnessSlider.addEventListener('input', updateFilters);
                                saturationSlider.addEventListener('input', updateFilters);
                                contrastSlider.addEventListener('input', updateFilters);

                                function updateFilters() {
                                    const brightness = lightnessSlider.value;
                                    const saturation = saturationSlider.value;
                                    const contrast = contrastSlider.value;
                                    const hueShift = hueShiftSlider.value;

                                    lightnessValue.textContent = brightness;
                                    saturationValue.textContent = saturation;
                                    contrastValue.textContent = contrast;
                                    hueShiftValue.textContent = hueShift;
                                    layers[currentLayer].style.filter = `brightness(${brightness}%) saturate(${saturation}%) contrast(${contrast}%) hue-rotate(${hueShift}deg)`;
                                }
                                // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Ñ–∏–ª—å—Ç—Ä–æ–≤ –∫ —Å–ª–æ—é
                                function applyFiltersToLayer(layerId) {
                                    const brightness = lightnessSlider.value;
                                    const saturation = saturationSlider.value;
                                    const contrast = contrastSlider.value;
                                    const hueShift = hueShiftSlider.value;

                                    layers[layerId].style.filter = `brightness(${brightness}%) saturate(${saturation}%) contrast(${contrast}%) hue-rotate(${hueShift}deg)`;
                                }

                            </script>
                            <script>
                                const symmetricPoints = [];
                                const back = 0
                                const layerCreationComplete = new Event('layerCreationComplete');

                                const elements = ['UploadB', 'fillModeBtn',
                                    'brushSize', 'opacity', 'pressureBar', 'backgroundPicker',
                                    'addLayerBtn', 'removeLayerBtn', 'eraserBtn', 'layerButtons',
                                    'zoomBtn', 'canvasContainer', 'drawOnExistingBtn', 'identifyLayerBtn', 'layerOpacitySlider', 'layerOpacityValue',
                                ];

                                const container = document.getElementById('canvasContainer');
                                const containerRect = container.getBoundingClientRect();
                                const obj = Object.fromEntries(
                                    elements.map(id => [id, document.getElementById(id)])
                                );
                                const layerPanel = document.querySelector('.layer-panel'),
                                    sidebar = document.querySelector(".sidebar"),
                                    layerOpacities = {},
                                    layers = [],
                                    contexts = {},
                                    layerColors = [],
                                    history = {},
                                    points = [],
                                    redoHistory = [];

                                const MAX_ZOOM = 100, MIN_ZOOM = 1, ZOOM_STEP = 0.02;

                                let layerCount = 0,
                                    symmetry = true,
                                    currentLayer = 1,
                                    previousLayer = 1,

                                    isSpider = false,

                                    curCtx,
                                    isDrawing = false,
                                    isErasing = false,
                                    isDrawOnExisting = false,
                                    zoomLevel = 1, // 1000% = 10
                                    isIdentifyingLayer = false,
                                    wasDrawing = false,
                                    isDraggingScroll = false,
                                    startY,
                                    currentCursor = 'auto',
                                    isZoomActive = false,
                                    offsetX = 0,
                                    offsetY = 0,
                                    lastX = null,
                                    lastY = null,
                                    uploadedImage = null,
                                    clearedCanvasState = null,
                                    isFillMode = false,
                                    zoomOriginX = 0,
                                    zoomOriginY = 0,
                                    isSmoothLineMode = false,
                                    isCtrlPressed = false;

                                const symmetryButton = document.getElementById('symmetry');

                                symmetryButton.addEventListener('click', toggleSymmetry);

                                const spiderButton = document.getElementById('spider');
                                spiderButton.addEventListener('click', toggleSpider);

                                // !
                                function toggleSymmetry() {
                                    symmetry = !symmetry;
                                    if (symmetry) {
                                        symmetryButton.classList.add('active');
                                    } else {
                                        symmetryButton.classList.remove('active');
                                    }
                                }

                                function toggleDrawOnExisting() {
                                    isDrawOnExisting = !isDrawOnExisting;
                                    drawOnExistingBtn.classList.toggle('active', isDrawOnExisting);
                                }
                                const spiderStrengthSlider = document.getElementById('spiderStrength');


                                function toggleSpider() {
                                    isSpider = !isSpider;
                                    spider.classList.toggle('active', isSpider);
                                    // Show or hide the slider based on the spider tool state
                                    spiderStrengthSlider.style.display = isSpider ? 'block' : 'none';
                                }


                            </script>
                            <script>

                                document.dispatchEvent(layerCreationComplete);
                                // Object.values(layers).forEach(addEventListenersToLayer);
                                drawOnExistingBtn.addEventListener('click', toggleDrawOnExisting);

                                // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø 
                                document.addEventListener('DOMContentLoaded', function () {

                                    initializeApp();
                                });

                                function initializeApp() {
                                    createLayer();
                                }

                                // —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –±—ç–∫–≥—Ä–∞—É–Ω–¥–∞
                                function setLayerBackground(layerIndex, imageUrl) {
                                    const img = new Image();
                                    img.onload = function () {
                                        contexts[layerIndex].drawImage(img, 0, 0, layers[layerIndex].width, layers[layerIndex].height);
                                    }
                                    img.src = imageUrl;
                                }
                                // —Å–æ–∑–¥–∞–Ω–∏–µ —Å–ª–æ–µ–≤
                                function createLayer() {

                                    updateZoom();
                                    if (!layers[back]) {
                                        const canvas = document.createElement('canvas');
                                        canvas.width = 600;
                                        canvas.height = 400;
                                        canvas.style.position = 'absolute';
                                        canvasContainer.appendChild(canvas);
                                        layers[0] = canvas;
                                        contexts[0] = canvas.getContext('2d', { willReadFrequently: true });
                                        setLayerBackground(back, 'images/canvas1.jpg');
                                    }

                                    layerCount++;
                                    layerColors[layerCount] = '#' + Math.floor(Math.random() * 16777215).toString(16);
                                    const canvas = document.createElement('canvas');
                                    canvas.id = `layer${layerCount}`;
                                    canvas.width = 600;
                                    canvas.height = 400;
                                    canvas.style.position = 'absolute';
                                    canvas.style.top = '0';
                                    canvas.style.left = '0';
                                    canvas.style.zIndex = layerCount;
                                    canvasContainer.appendChild(canvas);
                                    layers[layerCount] = canvas;
                                    contexts[layerCount] = canvas.getContext('2d', { willReadFrequently: true });
                                    const button = document.createElement('button');
                                    button.textContent = " ‚ù§ ";
                                    button.classList.add('layer-button');
                                    button.dataset.layer = layerCount;


                                    // Add eye icon
                                    const eyeIcon = document.createElement('span');
                                    eyeIcon.textContent = "üëÅÔ∏è";
                                    eyeIcon.style.display = 'none';
                                    eyeIcon.classList.add('eye-icon');
                                    button.appendChild(eyeIcon);


                                    layerButtons.appendChild(button);
                                    button.addEventListener('click', function () {
                                        setCurrentLayer(parseInt(this.dataset.layer));
                                    });
                                    addEventListenersToLayer(canvas);
                                    setCurrentLayer(layerCount);
                                    initializeLayer(layerCount);
                                    history[layerCount] = [];
                                    redoHistory[layerCount] = [];
                                    updateLayerButtonColor(layerCount);
                                    updateLayerOrder();
                                    // createHistorySlider(layerCount);
                                    layerDrawnOn[layerCount] = false; // Initialize as not drawn on

                                }


                                // button.addEventListener('click', function (event) {
                                //     setCurrentLayer(parseInt(this.dataset.layer));
                                //     showColorPicker(event);

                                //     addColorPickerToLayerButton(button);

                                // });

                                // —É—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç–µ–∫—É—â–µ–≥–æ —Å–ª–æ—è
                                function setCurrentLayer(layerNum) {
                                    if (layerNum === back) {
                                        return;
                                    }

                                    if (currentLayer !== layerNum) {
                                        previousLayer = currentLayer;
                                    }

                                    currentLayer = layerNum;
                                    curCtx = contexts[currentLayer];

                                    const opacity = layerOpacities[layerNum] || 100;
                                    layerOpacitySlider.value = opacity;
                                    layerOpacityValue.textContent = opacity;

                                    document.querySelectorAll('.layer-button').forEach(btn => {
                                        btn.classList.remove('active-layer');
                                        if (parseInt(btn.dataset.layer) === currentLayer) {
                                            btn.classList.add('active-layer');
                                        }
                                    });

                                    // if (!isErasing) {
                                    //     updateLayerButtonColor(layerNum);
                                    // }

                                    if (layerColors[layerNum]) {
                                        curCtx.strokeStyle = layerColors[layerNum];
                                    }
                                    updateLayerEyeIcon(layerNum);

                                }
                                // –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞ —Å–ª–æ–µ–≤
                                function updateLayerButtonColor(layerNum) {
                                    const button = document.querySelector(`.layer-button[data-layer="${layerNum}"]`);
                                    if (button && layerColors[layerNum]) {
                                        button.style.backgroundColor = layerColors[layerNum];
                                    }
                                }
                                // –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–ª–æ—è(–Ω—É–∂–Ω–æ —Ç–∞–∫ –∂–µ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –Ω–æ–≤–æ–≥–æ —Å–ª–æ—è)
                                function initializeLayer(layerNum) {

                                    contexts[layerNum].fillStyle = 'rgba(0,0,0,0)';
                                    contexts[layerNum].fillRect(0, 0, layers[layerNum].width, layers[layerNum].height);
                                }

                                // —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏
                                function saveState() {
                                    if (!curCtx) {
                                        return;
                                    }

                                    if (history[currentLayer].length >= MAX_HISTORY_STATES) {
                                        history[currentLayer].shift();
                                    }

                                    history[currentLayer].push(curCtx.getImageData(0, 0, layers[currentLayer].width, layers[currentLayer].height));

                                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–ª–æ—è –æ–±–≤–æ–¥–∫–∏, –µ—Å–ª–∏ –æ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
                                    if (outlineLayers[currentLayer]) {
                                        const outlineLayerId = outlineLayers[currentLayer].id;
                                        if (!history[outlineLayerId]) {
                                            history[outlineLayerId] = [];
                                        }
                                        if (history[outlineLayerId].length >= MAX_HISTORY_STATES) {
                                            history[outlineLayerId].shift();
                                        }
                                        history[outlineLayerId].push(contexts[outlineLayerId].getImageData(0, 0, layers[outlineLayerId].width, layers[outlineLayerId].height));
                                    }

                                    redoHistory[currentLayer] = [];

                                    // –û—á–∏—â–∞–µ–º redo –∏—Å—Ç–æ—Ä–∏—é –¥–ª—è —Å–ª–æ—è –æ–±–≤–æ–¥–∫–∏
                                    if (outlineLayers[currentLayer]) {
                                        redoHistory[outlineLayers[currentLayer].id] = [];
                                    }
                                }






                                function drawSpider(startX, startY, endX, endY, isSymmetric = false) {
                                    curCtx.beginPath();
                                    curCtx.moveTo(startX, startY);
                                    curCtx.quadraticCurveTo(startX, startY, endX, endY);
                                    curCtx.stroke();

                                    const targetPoints = isSymmetric ? symmetricPoints : points;
                                    targetPoints.push({ x: endX, y: endY });

                                    var power = spiderStrengthSlider.value;

                                    for (let i = 0; i < targetPoints.length; i++) {
                                        const dx = targetPoints[i].x - endX;
                                        const dy = targetPoints[i].y - endY;
                                        const dd = dx * dx + dy * dy;
                                        if (dd < power) {
                                            var mul = 0.1
                                            curCtx.beginPath();
                                            curCtx.moveTo(endX + (dx * mul), endY + (dy * mul));
                                            curCtx.lineTo(targetPoints[i].x - (dx * mul), targetPoints[i].y - (dy * mul));
                                            curCtx.stroke();
                                        }
                                    }
                                }

                                function startDrawing(e) {
                                    if (currentLayer === 100 || !curCtx || isEyedropperActive || isCtrlPressed) {
                                        return;
                                    }
                                    isDrawing = true;
                                    const rect = layers[currentLayer].getBoundingClientRect();
                                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                                    const x = Math.floor((clientX - rect.left) / zoomLevel);
                                    const y = Math.floor((clientY - rect.top) / zoomLevel);

                                    points.length = 0;
                                    symmetricPoints.length = 0;
                                    points.push({ x, y });

                                    [lastX, lastY] = [x, y];
                                    saveState();
                                }

                                function draw(e) {
                                    if (!isDrawing || !curCtx) {
                                        return;
                                    }
                                    if (isFinger) {
                                        finger(e);
                                        return;
                                    }
                                    const rect = layers[currentLayer].getBoundingClientRect();

                                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                                    const x = Math.floor((clientX - rect.left) / zoomLevel);
                                    const y = Math.floor((clientY - rect.top) / zoomLevel);

                                    const pressure = e.pressure || 1;
                                    curCtx.lineWidth = brushSize.value * pressure;
                                    curCtx.lineCap = 'round';
                                    curCtx.lineJoin = 'round';
                                    curCtx.globalAlpha = opacity.value / 100;
                                    curCtx.globalCompositeOperation = isErasing ? 'destination-out' : 'source-over';

                                    if (isSpider) {
                                        drawSpider(lastX, lastY, x, y, false);
                                    } else {
                                        if (isDrawOnExisting) {
                                            tools.drawOn(lastX, lastY, x, y, curCtx);
                                        } else {
                                            curCtx.beginPath();
                                            curCtx.moveTo(lastX, lastY);
                                            curCtx.lineTo(x, y);
                                            curCtx.stroke();
                                        }
                                    }

                                    if (symmetry) {
                                        const centerX = layers[currentLayer].width / 2;
                                        const symmetricLastX = centerX + (centerX - lastX);
                                        const symmetricX = centerX + (centerX - x);

                                        if (isSpider) {
                                            drawSpider(symmetricLastX, lastY, symmetricX, y, true);
                                        } else {
                                            if (isDrawOnExisting) {
                                                tools.drawOn(symmetricLastX, lastY, symmetricX, y, curCtx);
                                            } else {
                                                curCtx.beginPath();
                                                curCtx.moveTo(symmetricLastX, lastY);
                                                curCtx.lineTo(symmetricX, y);
                                                curCtx.stroke();
                                            }
                                        }
                                    }

                                    [lastX, lastY] = [x, y];
                                    pressureBar.value = pressure * 10000;
                                    pressureBar.nextElementSibling.textContent = Math.round(pressure * 100);
                                    layerDrawnOn[currentLayer] = true;
                                    updateLayerEyeIcon(currentLayer);
                                }

                                function stopDrawing() {
                                    if (isDrawing) {
                                        isDrawing = false;
                                        saveState();
                                        points.length = 0;
                                        symmetricPoints.length = 0;
                                    }
                                    lastX = null;
                                    lastY = null;
                                }

                                function endDrawing() {
                                    if (isDrawing) {
                                        isDrawing = false;
                                        lastX = null;
                                        lastY = null;
                                    }
                                }

                                function addEventListenersToLayer(layer) {
                                    // –≠—Ç–æ –º–µ—à–∞–ª–æ –Ω–∞–∂–∞—Ç–∏—è–º
                                    // layer.addEventListener("touchstart", startDrawing);
                                    // layer.addEventListener("touchmove", draw);
                                    layer.addEventListener('pointerdown', startDrawing);
                                    layer.addEventListener('pointermove', draw);
                                    layer.addEventListener('pointerup', endDrawing);
                                }
                            </script>
                            <script>
                                // –ø–∏–ø–µ—Ç–∫–∞ 
                                canvasContainer.addEventListener('click', handleEyedropperClick);
                                canvasContainer.addEventListener('touchstart', handleEyedropperClick);

                                const eyedropperBtn = document.getElementById('eyedropperBtn');
                                let isEyedropperActive = false;

                                eyedropperBtn.addEventListener('click', handleEyedropperActivation);
                                eyedropperBtn.addEventListener('touchstart', handleEyedropperActivation);

                                function handleEyedropperActivation(e) {
                                    e.preventDefault();

                                    isEyedropperActive = !isEyedropperActive;
                                    document.body.style.cursor = isEyedropperActive ? 'url(cursors/pipette.png), auto' : 'auto';
                                    eyedropperBtn.classList.toggle('active');

                                    if (isEyedropperActive) {
                                        isDrawing = false;
                                    }
                                }
                                function handleEyedropperClick(e) {
                                    if (!isEyedropperActive) return;

                                    e.preventDefault();

                                    // Determine whether the event is a touch event or a mouse event
                                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                                    const rect = layers[back].getBoundingClientRect();
                                    const x = Math.floor((clientX - rect.left) / zoomLevel); // Ensure x is an integer
                                    const y = Math.floor((clientY - rect.top) / zoomLevel);   // Ensure y is an integer

                                    // –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π canvas –¥–ª—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –≤—Å–µ—Ö —Å–ª–æ–µ–≤
                                    const tempCanvas = document.createElement('canvas');
                                    const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                                    tempCanvas.width = layers[back].width;
                                    tempCanvas.height = layers[back].height;

                                    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Å–ª–æ–∏ –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –∏—Ö –ø–æ z-index
                                    const sortedLayers = Object.entries(layers)
                                        .filter(([id]) => id !== back.toString())
                                        .sort((a, b) => parseInt(a[1].style.zIndex) - parseInt(b[1].style.zIndex));

                                    // –†–∏—Å—É–µ–º —Å–ª–æ–∏ –Ω–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ–º canvas –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
                                    tempCtx.drawImage(layers[back], 0, 0);
                                    sortedLayers.forEach(([, layer]) => {
                                        tempCtx.drawImage(layer, 0, 0);
                                    });

                                    // –ü–æ–ª—É—á–∞–µ–º —Ü–≤–µ—Ç –ø–∏–∫—Å–µ–ª—è
                                    const pixelData = tempCtx.getImageData(x, y, 1, 1).data; // This should now work correctly
                                    const color = `rgb(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]})`;

                                    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ü–≤–µ—Ç –∫–∏—Å—Ç–∏
                                    curCtx.strokeStyle = color;

                                    // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–≤–µ—Ç –∫–Ω–æ–ø–∫–∏ —Ç–µ–∫—É—â–µ–≥–æ —Å–ª–æ—è
                                    layerColors[currentLayer] = color;
                                    updateLayerButtonColor(currentLayer);

                                    // –û–±–Ω–æ–≤–ª—è–µ–º color picker, –µ—Å–ª–∏ –æ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
                                    const colorPicker = document.getElementById('colorPicker');

                                    // –î–µ–∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –ø–∏–ø–µ—Ç–∫—É
                                    isEyedropperActive = false;
                                    document.body.style.cursor = 'auto';
                                    eyedropperBtn.classList.remove('active');
                                }


                                // –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å —Å–ª–æ–µ–≤
                                function togglePreviousLayer() {
                                    [currentLayer, previousLayer] = [previousLayer, currentLayer];
                                    const layerButton = document.querySelector(`.layer-button[data-layer="${currentLayer}"]`);
                                    if (layerButton) {
                                        layerButton.click();
                                    }
                                }

                                // // –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Å–ª–æ—è
                                // canvasContainer.addEventListener('click', (e) => {
                                //     if (isIdentifyingLayer) {
                                //         identifyLayerClickHandler(e);
                                //         canvasContainer.style.cursor = 'default';
                                //         isDrawing = wasDrawing;
                                //         isIdentifyingLayer = false;
                                //         identifyLayerBtn.classList.remove('active');
                                //     }
                                // });
                                // identifyLayerBtn.addEventListener('click', () => {
                                //     isIdentifyingLayer = !isIdentifyingLayer;
                                //     identifyLayerBtn.classList.toggle('active', isIdentifyingLayer);
                                //     if (isIdentifyingLayer) {
                                //         wasDrawing = isDrawing;
                                //         isDrawing = false;
                                //         canvasContainer.style.cursor = 'crosshair';
                                //     } else {
                                //         canvasContainer.style.cursor = 'auto';
                                //         isDrawing = wasDrawing;
                                //     }
                                // });
                                // function identifyLayerClickHandler(e) {
                                //     const rect = layers[1].getBoundingClientRect();
                                //     const x = (e.clientX - rect.left) / zoomLevel;
                                //     const y = (e.clientY - rect.top) / zoomLevel;

                                //     // Collect all layer IDs except the background
                                //     const layerIds = Object.keys(layers).filter(key => key !== back);


                                //     layerIds.sort((a, b) => layers[b].style.zIndex - layers[a].style.zIndex);

                                //     // Iterate through layers from top to bottom
                                //     for (const layerId of layerIds) {
                                //         const ctx = contexts[layerId];
                                //         const pixelData = ctx.getImageData(x, y, 1, 1).data;
                                //         if (pixelData[3] > 0) {
                                //             setCurrentLayer(parseInt(layerId));
                                //             updateLayerButtonColor(parseInt(layerId));
                                //             return;
                                //         }
                                //     }
                                // }

                                // —Å–æ–∫—Ä–∞—Ç–∏—Ç—å
                                layerPanel.addEventListener("pointerenter", (e) => {
                                    e.preventDefault();
                                    isDraggingScroll = true;
                                    startY = e.clientY;
                                });
                                sidebar.addEventListener("pointerenter", (e) => {
                                    e.preventDefault();
                                    isDraggingScroll = true;
                                    startY = e.clientY;
                                });
                                sidebar.addEventListener('pointermove', (e) => {
                                    if (isDraggingScroll) {
                                        const deltaY = e.clientY - startY;
                                        sidebar.scrollTop += deltaY;
                                        startY = e.clientY;
                                    }
                                });
                                layerPanel.addEventListener('pointerdown', (e) => {
                                    e.preventDefault();
                                    isDraggingScroll = true;
                                    startY = e.clientY;
                                });

                                layerPanel.addEventListener('pointermove', (e) => {
                                    if (isDraggingScroll) {
                                        const deltaY = e.clientY - startY;
                                        layerPanel.scrollTop += deltaY;
                                        startY = e.clientY;
                                    }
                                });

                                // canvasContainer.addEventListener('pointerdown', handleCanvasClick);
                                // function handleCanvasClick(e) {
                                //     if (e.altKey) {
                                //         isDrawing = false;
                                //         e.preventDefault();
                                //         identifyLayerClickHandler(e);
                                //     }
                                // }
                                function updateLayerOrder() {
                                    const layerButtons = Array.from(document.querySelectorAll('.layer-button'));
                                    const baseZIndex = 110;

                                    layerButtons.forEach((button, index) => {
                                        const layerId = parseInt(button.dataset.layer);
                                        if (layers[layerId]) {
                                            const zIndex = layerId === back ? -100 : baseZIndex + layerButtons.length - index;
                                            layers[layerId].style.zIndex = zIndex;

                                            if (outlineLayers[layerId]) {
                                                layers[outlineLayers[layerId].id].style.zIndex = zIndex + 1;
                                            }
                                        }
                                    });
                                }


                                function handleMoveLayerClick(event) {
                                    const direction = event.target === moveLayerUp ? -1 : 1;
                                    moveLayerInStack(direction);
                                }

                                // moveLayerUpBtn.addEventListener('click', handleMoveLayerClick);
                                // moveLayerDownBtn.addEventListener('click', handleMoveLayerClick);

                                moveLayerUp.addEventListener('click', () => {
                                    moveLayerInStack(-1);
                                });
                                moveLayerDown.addEventListener('click', () => {
                                    moveLayerInStack(1);
                                });
                                function moveLayerInStack(direction) {
                                    const curLB = document.querySelector(`.layer-button[data-layer="${currentLayer}"]`);
                                    const targetLayerButton = direction === -1
                                        ? curLB.previousElementSibling
                                        : curLB.nextElementSibling;

                                    if (targetLayerButton) {
                                        // –ü–µ—Ä–µ–º–µ—â–∞–µ–º –∫–Ω–æ–ø–∫—É —Å–ª–æ—è –≤ DOM
                                        if (direction === -1) {
                                            curLB.parentNode.insertBefore(curLB, targetLayerButton);
                                        } else {
                                            curLB.parentNode.insertBefore(targetLayerButton, curLB);
                                        }

                                        // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ—Ä—è–¥–æ–∫ —Å–ª–æ–µ–≤
                                        updateLayerOrder();

                                        // –ü–µ—Ä–µ–º–µ—â–∞–µ–º —Å–ª–æ–π –æ–±–≤–æ–¥–∫–∏ –≤–º–µ—Å—Ç–µ —Å –æ—Å–Ω–æ–≤–Ω—ã–º —Å–ª–æ–µ–º
                                        if (outlineLayers[currentLayer]) {
                                            const outlineLayerId = outlineLayers[currentLayer].id;
                                            const outlineLayer = layers[outlineLayerId];
                                            const mainLayer = layers[currentLayer];
                                            outlineLayer.style.zIndex = parseInt(mainLayer.style.zIndex) + 1;
                                        }

                                        // –ê–∫—Ç–∏–≤–∏—Ä—É–µ–º –ø–µ—Ä–µ–º–µ—â–µ–Ω–Ω—ã–π —Å–ª–æ–π
                                        curLB.click();
                                    }

                                }
                                const layerButtonsContainer = document.getElementById('layerButtons');
                                // Zoom functions
                                document.addEventListener('keydown', (e) => {
                                    if (e.key === 'Control') {
                                        isCtrlPressed = true;
                                    }
                                    // fix
                                    lastX = null;
                                    lastY = null;
                                });

                                document.addEventListener('keyup', (e) => {
                                    if (e.key === 'Control') {
                                        isCtrlPressed = false;
                                        // fix —Å–±—Ä—Ä–æ—Å
                                        lastX = null;
                                        lastY = null;
                                    }
                                });



                                canvasContainer.addEventListener('mousemove', (e) => {
                                    e.preventDefault();
                                    if (isEyedropperActive || !isCtrlPressed || isDrawing || isFinger) return;



                                    const rect = canvasContainer.getBoundingClientRect();
                                    const mouseX = e.clientX - rect.left;
                                    const mouseY = e.clientY - rect.top;

                                    if (lastX !== undefined) {
                                        const deltaX = e.movementX;
                                        const oldZoom = zoomLevel;
                                        zoomLevel = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, zoomLevel + deltaX * ZOOM_STEP));

                                        if (oldZoom !== zoomLevel) {
                                            zoomOriginX = (mouseX - offsetX) / oldZoom;
                                            zoomOriginY = (mouseY - offsetY) / oldZoom;

                                            offsetX = mouseX - zoomOriginX * zoomLevel;
                                            offsetY = mouseY - zoomOriginY * zoomLevel;

                                            updateZoom();
                                        }
                                    }

                                    lastX = mouseX;
                                    lastY = mouseY;
                                });




                                function updateZoom() {


                                    Object.values(layers).forEach(layer => {

                                        layer.style.transformOrigin = '0 0';

                                        if (zoomLevel <= 1) {
                                            offsetX = 0;
                                            offsetY = 0;
                                            layer.style.transform = `scale(${zoomLevel})`;
                                            layer.style.left = '0';
                                            layer.style.top = '0';
                                        } else {
                                            layer.style.transform = `scale(${zoomLevel})`;

                                            const layerRect = layer.getBoundingClientRect();
                                            offsetX = Math.min(Math.max(offsetX, containerRect.width - layerRect.width), 0);
                                            offsetY = Math.min(Math.max(offsetY, containerRect.height - layerRect.height), 0);

                                            layer.style.left = `${offsetX}px`;
                                            layer.style.top = `${offsetY}px`;
                                        }
                                    });

                                    canvasContainer.style.overflow = 'hidden';
                                    // –∏–∫–æ–Ω–∫–∞ –∏ –∑—É–º –≤ html
                                    document.getElementById('zoomLevelDisplay').textContent = `üîé${(zoomLevel * 100).toFixed(0)}%`;
                                }


                            </script>
                            <script src="script.js" defer></script>
                            <script src="cursors.js" defer></script>
                            <script type="module" src="constants.js" defer></script>
                            <script type="module" src="main.js" defer></script>
                            <script type="module" src="settings.js" defer></script>
                            <script type="module" src="helperFunction.js" defer></script>
                            <script type="module" src="listners.js" defer></script>
                            <script type="module" src="hotkey.js" defer></script>
                            <script type="module" src="settingsPanel.js" defer></script>
                            <script type="module" src="tools.js" defer></script>
                            <script>


                                //  –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –ø–∞–ª–µ—Ü
                                let isFinger = false;

                                const fingerBtn = document.getElementById('fingerBtn');

                                fingerBtn.addEventListener('click', () => {
                                    isFinger = !isFinger;
                                    fingerBtn.classList.toggle('active', isFinger);
                                });
                                function finger(e) {

                                    if (!isDrawing || !curCtx || !isFinger) return;

                                    const rect = layers[currentLayer].getBoundingClientRect();
                                    const x = Math.floor((e.clientX - rect.left) / zoomLevel);
                                    const y = Math.floor((e.clientY - rect.top) / zoomLevel);

                                    const brushSize = parseInt(brushSize.value);
                                    const halfBrushSize = brushSize / 2;

                                    curCtx.save();
                                    curCtx.beginPath();
                                    curCtx.arc(x, y, halfBrushSize, 0, Math.PI * 2);
                                    curCtx.clip();

                                    if (lastX !== null && lastY !== null) {
                                        const dx = x - lastX;
                                        const dy = y - lastY;
                                        curCtx.drawImage(
                                            layers[currentLayer],
                                            x - halfBrushSize - dx, y - halfBrushSize - dy, brushSize, brushSize,
                                            x - halfBrushSize, y - halfBrushSize, brushSize, brushSize
                                        );
                                    }

                                    curCtx.restore();

                                    lastX = x;
                                    lastY = y;
                                }
                                const MAX_HISTORY_STATES = 1000;

                                // –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º
                                function moveCanvasContent(layerId, direction, amount) {
                                    const canvas = layers[layerId];
                                    const ctx = contexts[layerId];

                                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–∞–Ω–≤–∞—Å–∞
                                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                                    // –û—á–∏—â–∞–µ–º –∫–∞–Ω–≤–∞—Å
                                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                                    // –í—ã—á–∏—Å–ª—è–µ–º —Å–º–µ—â–µ–Ω–∏–µ
                                    let offsetX = 0, offsetY = 0;
                                    switch (direction) {
                                        case 'left':
                                            offsetX = -amount;
                                            break;
                                        case 'right':
                                            offsetX = amount;
                                            break;
                                        case 'up':
                                            offsetY = -amount;
                                            break;
                                        case 'down':
                                            offsetY = amount;
                                            break;
                                    }

                                    // –†–∏—Å—É–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∫–∞–Ω–≤–∞—Å–∞ —Å–æ —Å–º–µ—â–µ–Ω–∏–µ–º
                                    ctx.putImageData(imageData, offsetX, offsetY);

                                    // –ï—Å–ª–∏ —á–∞—Å—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤—ã—à–ª–∞ –∑–∞ –ø—Ä–µ–¥–µ–ª—ã –∫–∞–Ω–≤–∞—Å–∞, —Ä–∏—Å—É–µ–º –µ–µ —Å –¥—Ä—É–≥–æ–π —Å—Ç–æ—Ä–æ–Ω—ã
                                    if (offsetX > 0) {
                                        ctx.putImageData(imageData, offsetX - canvas.width, 0, canvas.width - offsetX, 0, offsetX, canvas.height);
                                    } else if (offsetX < 0) {
                                        ctx.putImageData(imageData, canvas.width + offsetX, 0, 0, 0, -offsetX, canvas.height);
                                    }

                                    if (offsetY > 0) {
                                        ctx.putImageData(imageData, 0, offsetY - canvas.height, 0, canvas.height - offsetY, canvas.width, offsetY);
                                    } else if (offsetY < 0) {
                                        ctx.putImageData(imageData, 0, canvas.height + offsetY, 0, 0, canvas.width, -offsetY);
                                    }

                                    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–ª–æ—è
                                    layerDrawnOn[layerId] = true;
                                    updateLayerEyeIcon(layerId);
                                }




                                // –û–±–≤–æ–¥–∫–∞
                                const outlineLayers = {};
                                const outlineSizes = {};
                                let isInnerOutline = false;

                                // –ü–æ–ª—É—á–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç DOM –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ü–≤–µ—Ç–∞ –æ–±–≤–æ–¥–∫–∏
                                const outlineColorPicker = document.getElementById('outlineColorPicker');

                                // –ü–æ–ª—É—á–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã DOM
                                const toggleOutlineTypeBtn = document.getElementById('toggleOutlineTypeBtn');
                                const outlineSizeInput = document.getElementById('outlineSize');
                                const outlineSizeValue = document.getElementById('outlineSizeValue');

                                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è input —Ä–∞–∑–º–µ—Ä–∞ –æ–±–≤–æ–¥–∫–∏
                                outlineSizeInput.max = "20";

                                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –¥–ª—è –∫–Ω–æ–ø–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è —Ç–∏–ø–∞ –æ–±–≤–æ–¥–∫–∏
                                toggleOutlineTypeBtn.addEventListener('click', () => {
                                    isInnerOutline = !isInnerOutline;
                                    toggleOutlineTypeBtn.textContent = isInnerOutline ? 'üîΩ' : 'üîº';
                                    applyOutline(currentLayer, parseInt(outlineSizeInput.value));
                                });

                                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–±—ã—Ç–∏—è –¥–ª—è input —Ä–∞–∑–º–µ—Ä–∞ –æ–±–≤–æ–¥–∫–∏
                                outlineSizeInput.addEventListener('input', function () {
                                    const size = parseInt(this.value);
                                    outlineSizeValue.textContent = size;
                                    applyOutline(currentLayer, size);
                                });

                                // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –æ–±–≤–æ–¥–∫–∏ –∫ —Å–ª–æ—é
                                function applyOutline(layerNum, size) {
                                    saveState(); // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–µ—Ä–µ–¥ –∏–∑–º–µ–Ω–µ–Ω–∏–µ–º

                                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Å–ª–æ—è –∏ –µ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
                                    if (!layers[layerNum] || !contexts[layerNum]) {
                                        return;
                                    }

                                    // –ü–æ–ª—É—á–∞–µ–º ID —Å–ª–æ—è –æ–±–≤–æ–¥–∫–∏, –µ—Å–ª–∏ –æ–Ω —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
                                    let outlineLayerId = outlineLayers[layerNum] ? outlineLayers[layerNum].id : null;

                                    // –ï—Å–ª–∏ —Å–ª–æ–π –æ–±–≤–æ–¥–∫–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, —Å–æ–∑–¥–∞–µ–º –µ–≥–æ
                                    if (!outlineLayerId) {
                                        outlineLayerId = createOutlineLayer(layerNum);
                                    }

                                    // –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç—ã —Å–ª–æ—è –æ–±–≤–æ–¥–∫–∏ –∏ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ —Å–ª–æ—è
                                    const outlineCtx = contexts[outlineLayerId];
                                    const sourceCtx = contexts[layerNum];
                                    const canvas = layers[layerNum];

                                    // –û—á–∏—â–∞–µ–º —Å–ª–æ–π –æ–±–≤–æ–¥–∫–∏
                                    outlineCtx.clearRect(0, 0, canvas.width, canvas.height);

                                    // –ï—Å–ª–∏ —Ä–∞–∑–º–µ—Ä –æ–±–≤–æ–¥–∫–∏ –±–æ–ª—å—à–µ 0, —Å–æ–∑–¥–∞–µ–º –∏ –ø—Ä–∏–º–µ–Ω—è–µ–º –æ–±–≤–æ–¥–∫—É

                                    if (size > 0) {
                                        const imageData = sourceCtx.getImageData(0, 0, canvas.width, canvas.height);
                                        const outlineImageData = outlineCtx.createImageData(canvas.width, canvas.height);

                                        requestAnimationFrame(() => {
                                            createOutline(imageData, outlineImageData, size, canvas.width, canvas.height, isInnerOutline);
                                            outlineCtx.putImageData(outlineImageData, 0, 0);
                                            outlineSizes[layerNum] = size;
                                            updateLayerList();
                                        });
                                    } else {
                                        requestAnimationFrame(() => {
                                            outlineSizes[layerNum] = size;
                                            updateLayerList();
                                        });
                                    }
                                }


                                // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–ª–æ—è –æ–±–≤–æ–¥–∫–∏
                                function createOutlineLayer(layerNum) {
                                    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π canvas –¥–ª—è —Å–ª–æ—è –æ–±–≤–æ–¥–∫–∏
                                    const outlineCanvas = document.createElement('canvas');
                                    outlineCanvas.width = layers[layerNum].width;
                                    outlineCanvas.height = layers[layerNum].height;
                                    const outlineCtx = outlineCanvas.getContext('2d', { willReadFrequently: true });

                                    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π –∏–Ω–¥–µ–∫—Å –¥–ª—è —Å–ª–æ—è –æ–±–≤–æ–¥–∫–∏
                                    const newLayerIndex = Math.max(...Object.keys(layers).map(Number)) + 1;

                                    // –î–æ–±–∞–≤–ª—è–µ–º —Å–ª–æ–π –æ–±–≤–æ–¥–∫–∏ –≤ —Å–ø–∏—Å–æ–∫ —Å–ª–æ–µ–≤ –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤
                                    layers[newLayerIndex] = outlineCanvas;
                                    contexts[newLayerIndex] = outlineCtx;

                                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–ª–æ–µ –æ–±–≤–æ–¥–∫–∏
                                    outlineLayers[layerNum] = {
                                        id: newLayerIndex,
                                        canvas: outlineCanvas
                                    };

                                    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º z-index —Å–ª–æ—è –æ–±–≤–æ–¥–∫–∏ –≤—ã—à–µ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ —Å–ª–æ—è
                                    outlineCanvas.style.zIndex = parseInt(layers[layerNum].style.zIndex) + 1;

                                    // –í—Å—Ç–∞–≤–ª—è–µ–º —Å–ª–æ–π –æ–±–≤–æ–¥–∫–∏ –≤ DOM –ø–µ—Ä–µ–¥ –∏—Å—Ö–æ–¥–Ω—ã–º —Å–ª–æ–µ–º
                                    canvasContainer.insertBefore(outlineCanvas, layers[layerNum].nextSibling);

                                    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∏—Å—Ç–æ—Ä–∏—é –∏–∑–º–µ–Ω–µ–Ω–∏–π –¥–ª—è —Å–ª–æ—è –æ–±–≤–æ–¥–∫–∏
                                    history[newLayerIndex] = [];
                                    redoHistory[newLayerIndex] = [];
                                    layerOpacities[newLayerIndex] = 100;

                                    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏–Ω–¥–µ–∫—Å –Ω–æ–≤–æ–≥–æ —Å–ª–æ—è –æ–±–≤–æ–¥–∫–∏
                                    return newLayerIndex;
                                }
                                function createOutline(sourceImageData, outlineImageData, size, width, height, isInner) {
                                    const sourceData = sourceImageData.data;
                                    const outlineData = outlineImageData.data;
                                    const outlineColor = hexToRgb(outlineColorPicker.value);

                                    for (let y = 0; y < height; y++) {
                                        for (let x = 0; x < width; x++) {
                                            const index = (y * width + x) * 4;
                                            if ((isInner && sourceData[index + 3] > 0) || (!isInner && sourceData[index + 3] === 0)) {
                                                if (hasNeighborWithDifferentAlpha(sourceData, x, y, width, height, size, isInner)) {
                                                    outlineData.set(outlineColor, index);
                                                }
                                            }
                                        }
                                    }
                                }

                                function hasNeighborWithDifferentAlpha(sourceData, x, y, width, height, size, isInner) {
                                    const targetAlpha = isInner ? 0 : 255;
                                    for (let dy = -size; dy <= size; dy++) {
                                        for (let dx = -size; dx <= size; dx++) {
                                            const nx = x + dx;
                                            const ny = y + dy;
                                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                                const neighborIndex = (ny * width + nx) * 4 + 3;
                                                if (sourceData[neighborIndex] === targetAlpha) {
                                                    return true;
                                                }
                                            }
                                        }
                                    }
                                    return false;
                                }


                                // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ hex —Ü–≤–µ—Ç–∞ –≤ rgb –º–∞—Å—Å–∏–≤
                                function hexToRgb(hex) {
                                    // –£–±–∏—Ä–∞–µ–º —Å–∏–º–≤–æ–ª # –≤ –Ω–∞—á–∞–ª–µ, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
                                    hex = hex.replace('#', '');

                                    // –ü–∞—Ä—Å–∏–º hex –∑–Ω–∞—á–µ–Ω–∏–µ –≤ rgb –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
                                    const r = parseInt(hex.substring(0, 2), 16);
                                    const g = parseInt(hex.substring(2, 4), 16);
                                    const b = parseInt(hex.substring(4, 6), 16);

                                    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –º–∞—Å—Å–∏–≤ [r, g, b]
                                    return [r, g, b, 255]; // 255 –¥–ª—è alpha –∫–∞–Ω–∞–ª–∞
                                }

                                // –û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è —Å–ª–æ—è –≤ —Å—Ç–µ–∫–µ (–≤–≤–µ—Ä—Ö/–≤–Ω–∏–∑)
                                function moveLayerInStack(direction) {
                                    const curLB = document.querySelector(`.layer-button[data-layer="${currentLayer}"]`);
                                    const targetLayerButton = direction === -1 ? curLB.previousElementSibling : curLB.nextElementSibling;

                                    if (targetLayerButton) {
                                        // –ü–µ—Ä–µ–º–µ—â–∞–µ–º –∫–Ω–æ–ø–∫—É —Å–ª–æ—è –≤ DOM
                                        if (direction === -1) {
                                            curLB.parentNode.insertBefore(curLB, targetLayerButton);
                                        } else {
                                            curLB.parentNode.insertBefore(targetLayerButton, curLB);
                                        }

                                        // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ—Ä—è–¥–æ–∫ —Å–ª–æ–µ–≤
                                        updateLayerOrder();

                                        // –ü–µ—Ä–µ–º–µ—â–∞–µ–º —Å–ª–æ–π –æ–±–≤–æ–¥–∫–∏ –≤–º–µ—Å—Ç–µ —Å –æ—Å–Ω–æ–≤–Ω—ã–º —Å–ª–æ–µ–º
                                        if (outlineLayers[currentLayer]) {
                                            const outlineLayerId = outlineLayers[currentLayer].id;
                                            const outlineLayer = layers[outlineLayerId];
                                            const mainLayer = layers[currentLayer];
                                            outlineLayer.style.zIndex = parseInt(mainLayer.style.zIndex) + 1;
                                        }

                                        // –ê–∫—Ç–∏–≤–∏—Ä—É–µ–º –ø–µ—Ä–µ–º–µ—â–µ–Ω–Ω—ã–π —Å–ª–æ–π
                                        curLB.click();
                                    }
                                }

                                // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ—Ä—è–¥–∫–∞ —Å–ª–æ–µ–≤ –≤ DOM
                                function updateLayerOrder() {
                                    const layerButtons = Array.from(document.querySelectorAll('.layer-button'));

                                    layerButtons.forEach((button, index) => {
                                        const layerId = parseInt(button.dataset.layer);

                                        if (layers[layerId]) {
                                            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º z-index –¥–ª—è —Ñ–æ–Ω–æ–≤–æ–≥–æ —Å–ª–æ—è
                                            if (layerId === back) {
                                                layers[layerId].style.zIndex = -100;
                                            } else {
                                                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º z-index –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Å–ª–æ–µ–≤
                                                const zIndex = layerButtons.length - index + 110;
                                                layers[layerId].style.zIndex = zIndex;

                                                // –û–±–Ω–æ–≤–ª—è–µ–º z-index —Å–ª–æ—è –æ–±–≤–æ–¥–∫–∏, –µ—Å–ª–∏ –æ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
                                                if (outlineLayers[layerId]) {
                                                    const outlineLayerId = outlineLayers[layerId].id;
                                                    layers[outlineLayerId].style.zIndex = zIndex + 1;
                                                }
                                            }
                                        }
                                    });
                                }

                                // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ —Å–ª–æ–µ–≤ –≤ –ø–∞–Ω–µ–ª–∏ —Å–ª–æ–µ–≤
                                function updateLayerList() {
                                    const layerButtonsContainer = document.getElementById('layerButtons');
                                    layerButtonsContainer.innerHTML = ''; // –û—á–∏—â–∞–µ–º —Ç–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ —Å–ª–æ–µ–≤

                                    // –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Å–ª–æ–µ–≤, –∫—Ä–æ–º–µ —Ñ–æ–Ω–æ–≤–æ–≥–æ
                                    const allLayers = Object.keys(layers).filter(id => id !== back.toString());

                                    // –°–æ—Ä—Ç–∏—Ä—É–µ–º —Å–ª–æ–∏ –ø–æ z-index
                                    allLayers.sort((a, b) => parseInt(layers[b].style.zIndex) - parseInt(layers[a].style.zIndex));

                                    // –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–ª–æ—è
                                    allLayers.forEach((layerId) => {
                                        createLayerButton(layerId, layerButtonsContainer);
                                    });

                                    // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ—Ä—è–¥–æ–∫ —Å–ª–æ–µ–≤ –≤ DOM
                                    updateLayerOrder();

                                    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–π —Å–ª–æ–π
                                    const activeLayerButton = layerButtonsContainer.querySelector(`[data-layer="${currentLayer}"]`);
                                    if (activeLayerButton) {
                                        activeLayerButton.classList.add('active-layer');
                                    }
                                }

                                // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–Ω–æ–ø–∫–∏ —Å–ª–æ—è –≤ –ø–∞–Ω–µ–ª–∏ —Å–ª–æ–µ–≤
                                function createLayerButton(layerId, container) {
                                    const button = document.createElement('button');
                                    button.textContent = " ‚ù§ ";
                                    button.classList.add('layer-button');
                                    button.dataset.layer = layerId;

                                    // –î–æ–±–∞–≤–ª—è–µ–º –∏–∫–æ–Ω–∫—É –≥–ª–∞–∑–∞
                                    const eyeIcon = document.createElement('span');
                                    eyeIcon.textContent = "üëÅÔ∏è";
                                    eyeIcon.style.display = layerDrawnOn[layerId] ? 'inline' : 'none';
                                    eyeIcon.classList.add('eye-icon');
                                    button.appendChild(eyeIcon);

                                    // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –Ω–∞ –∫–Ω–æ–ø–∫—É —Å–ª–æ—è
                                    button.addEventListener('click', function () {
                                        setCurrentLayer(parseInt(this.dataset.layer));
                                    });

                                    // –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É —Å–ª–æ—è –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
                                    container.appendChild(button);

                                    // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–≤–µ—Ç –∫–Ω–æ–ø–∫–∏ —Å–ª–æ—è
                                    updateLayerButtonColor(layerId);
                                }


                            </script>
                            <script>
                                // !?
                                // document.querySelectorAll('button, input').forEach(element => {
                                //      element.addEventListener('pointerdown', (e) => {
                                //          e.stopPropagation();
                                //      });
                                //   });


                            </script>
                            <script>
                                // –¥–æ–±–∞–≤–ª—è–µ–º –∏–∫–æ–Ω–∫—É –∑–∞–¥–µ–π—Å—Ç–≤–æ–≤–∞–Ω–Ω—ã—Ö —Å–ª–æ–µ–≤
                                const layerDrawnOn = {};
                                function updateLayerEyeIcon(layerNum) {
                                    const layerButton = document.querySelector(`.layer-button[data-layer="${layerNum}"]`);
                                    if (layerButton) {
                                        const eyeIcon = layerButton.querySelector('.eye-icon');
                                        if (eyeIcon) {
                                            eyeIcon.style.display = layerDrawnOn[layerNum] ? 'inline' : 'none';
                                        }
                                    }
                                }
                                // —Å–æ–æ–±—â–µ–Ω–∏–µ
                                const messageButton = document.getElementById('message');
                                const messageContainer = document.getElementById('message-container');
                                const messageText = document.getElementById('message-text');

                                function showMessage(message) {
                                    messageText.textContent = message;
                                    messageContainer.style.display = 'block';
                                }

                                messageButton.addEventListener('click', () => {
                                    showMessage("–ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ."); // Show a test message
                                });

                                if (!messageContainer.querySelector('.close-button')) {
                                    const closeButton = document.createElement('span');
                                    closeButton.textContent = '√ó';
                                    closeButton.classList.add('close-button');
                                    messageContainer.appendChild(closeButton);

                                    closeButton.addEventListener('click', () => {
                                        messageContainer.style.display = 'none';
                                    });
                                }

                                window.addEventListener('click', (event) => {
                                    if (event.target === messageContainer) {
                                        messageContainer.style.display = 'none';
                                    }
                                });

                            </script>
                            </script>
</body>

</html>