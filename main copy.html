<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- –æ—Ç–∫–ª—é—á–µ–Ω–∏–µ –º–∞—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–ù–∞—Å—Ç–æ—è—â–∏–π –•—É–¥–æ–∂–Ω–∏–∫</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jscolor/2.4.5/jscolor.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
</head>

<body>
    <style>
    </style>
    <div class="base-container">
        <div class="sidebar">
            <a href="index.html" target="_self" title="–í—ã–π—Ç–∏ –∏–∑ –∫–æ–º–∞–Ω—Ç—ã" id="exitLink">üö™</a>
<button id="message" title="–°–æ–æ–±—â–µ–Ω–∏–µ">‚úâÔ∏è</button>
<div id="message-container" class="message-popup">
  <p id="message-text"></p>
</div>

            <div class="sidebar">
            </div>
            <button id="backgroundSettingsBtn" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ñ–æ–Ω–∞">üñºÔ∏è</button>
            <button id="canvasSettingsBtn" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–∞–Ω–≤–∞—Å–∞">üñåÔ∏è</button>
            <button id="fullscreenBtn" title="–ü–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π —Ä–µ–∂–∏–º">üî≤</button>
            <button id="spider" title="–ü–∞—É—Ç–∏–Ω–∫–∞">üï∑Ô∏è</button>
            <button id="fingerfunc" title="–°—É–∂–µ–Ω–∏–µ –∫ —Ü–µ–Ω—Ç—Ä—É">üéØ</button>
            <button id="identifyLayerBtn" title="–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å–ª–æ–π">üîç</button>
            <button id="drawOnExistingBtn" title="–†–∏—Å–æ–≤–∞—Ç—å –Ω–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–º">‚û°Ô∏è</button>
            <input type="file" id="imageInput" accept="image/*" style="display: none;">
            <button id="UploadB" title="–ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (U)">üå∫</button>
            <button id="saveImageBtn" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ">üé¨</button>
            <button id="eraserBtn">üßΩ</button>
            <button id="changeCursorBtn" title="–°–º–µ–Ω–∏—Ç—å –∫—É—Ä—Å–æ—Ä">üé®</button>
            <button id="undoBtn" title="–û—Ç–º–µ–Ω–∏—Ç—å (Z)">‚ü≤</button>
            <button id="redoBtn" title="–ü–æ–≤—Ç–æ—Ä–∏—Ç—å (X)">‚ü≥</button>
            <button id="clear" title="–û—á–∏—Å—Ç–∏—Ç—å">üíÄ</button>
            <button id="fillModeBtn" title="–ó–∞–ª–∏–≤–∫–∞ (F)">üåä</button>
            <button id="floodFillBtn" title="–ó–∞–ª–∏—Ç—å —Ü–≤–µ—Ç–æ–º">‚ú®</button>
            <button id="eyedropperBtn" title="–ü–∏–ø–µ—Ç–∫–∞ –∑–∞–ª–∏–≤–∫–∏ (A)">üíß</button>
            <button id="deleteAllBtn" title="–£–¥–∞–ª–∏—Ç—å –≤—Å–µ">üóëÔ∏è</button>
            <button id="mergeLayers" title="–û–±—ä–µ–¥–∏–Ω–∏—Ç—å —Å–ª–æ–∏">üîó</button>
            <button id="settings" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏">‚öôÔ∏è</button>

        </div>
        <div id="colorPreview"></div>
        <div class="canvas-and-sliders">
            <div class="layer-panel-wrapper">
                <button id="moveLayerUp" title="–°–ª–æ–π –≤–≤–µ—Ä—Ö">‚ñ≤</button>
                <div class="layer-panel">
                    <div id="layerButtons"></div>
                </div>
                <button id="moveLayerDown" title="–°–ª–æ–π –≤–Ω–∏–∑">‚ñº</button>
            </div>
            <div class="canvas-container">
                <div class="color-picker-and-word">
                    <div class="color-picker-group">
                        <input type="color" id="colorPicker" value="#000000" title="–¶–≤–µ—Ç –∑–∞–ª–∏–≤–∫–∏ (C)">
                        <input type="color" id="colorPicker2" value="#ffffff" title="–±—É–ª—ã–π">
                        <input type="color" id="colorPicker3" value="#ff0000" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 3">
                        <input type="color" id="colorPicker4" value="#ffa500" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 4">
                        <input type="color" id="colorPicker5" value="#ffff00" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 5">
                        <input type="color" id="colorPicker6" value="#008000" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 6">
                        <input type="color" id="colorPicker7" value="#00ffff" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 7">
                        <input type="color" id="colorPicker8" value="#0000ff" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 8">
                        <input type="color" id="colorPicker9" value="#800080" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 9">
                        <input type="color" id="backgroundPicker" value="#ffffff" title="–¶–≤–µ—Ç —Ñ–æ–Ω–∞ (B)">
                        <div class="color-picker-group-two">
                        </div>
                        <button id="symmetry" title="–°–∏–º–º–µ—Ç—Ä–∏—è (S)">ü¶ã</button>
                    </div>
                    <div class="word-navigation">
                        <button id="previousWord" title="–ü—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–ª–æ–≤–æ">&lt;</button>
                        <p id="Quizz"></p>
                        <button id="nextWord" title="–°–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ">&gt;</button>
                    </div>
                    <div class="header-container">
                        <div class="time-wrapper">
                            <span id="time" class="time"></span>
                            <span id="startTime" class="time"></span>
                            <span id="elapsedTime" class="time"></span>
                            <button id="zoomBtn" title="–õ—É–ø–∞"></button>
                            <div id="zoomLevelDisplay" title="–£—Ä–æ–≤–µ–Ω—å –∑—É–º–∞"></div>
                        </div>
                    </div>
                </div>
                <div class="canv-container" id="canvasContainer">
                    <div id="cursorPanel" class="cursor-panel" style="display: none;">
                        <h3>–í—ã–±–µ—Ä–∏—Ç–µ –∫—É—Ä—Å–æ—Ä</h3>
                        <div id="cursorList"></div>
                    </div>
                </div>
                <div class="sliders">
                    <label for="spiderStrength" title="–°–∏–ª–∞ –ø–∞—É–∫–∞" style="display: none;">üï∏Ô∏è</label>
                    <input type="range" id="spiderStrength" min="50" max="10000" value="1000" title="–°–∏–ª–∞ –ø–∞—É–∫–∞"
                        style="display: none;">
                </div>
                <div class="sliders">
                    <label for="opacity" title="–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å">üëª</label>
                    <input type="range" id="opacity" min="1" max="100" value="100">
                    <span id="opacityValue" style="color: red;">100</span>
                    <label for="layerOpacitySlider" title="–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å —Å–ª–æ—è">üëì</label>
                    <input type="range" id="layerOpacitySlider" min="0" max="100" value="100">
                    <span id="layerOpacityValue" style="color: red;">100</span>
                </div>
                <div class="sliders">
                    <label for="brushSize" title="–†–∞–∑–º–µ—Ä –∫–∏—Å—Ç–∏">üñåÔ∏è</label>
                    <input type="range" id="brushSize" min="1" max="300" value="3">
                    <span id="brushSizeValue" style="color: red;">3</span>
                    <div class="pressure-bar-container">
                        <label for="pressureBar" title="–ù–∞–∂–∏–º">üéØ</label>
                        <progress id="pressureBar" value="0" max="4000"></progress>
                        <span id="pressureValue" class="pressure-value"></span>
                        <div class="sliders">
                            <label for="outlineSize" title="–†–∞–∑–º–µ—Ä –æ–±–≤–æ–¥–∫–∏">üñºÔ∏è</label>
                            <input type="range" id="outlineSize" min="0" max="20" value="0">
                            <span id="outlineSizeValue" style="color: red;">0</span>
                        </div>
                    </div>
                    <style>
                        .pressure-value {
                            font-size: 12px;
                            color: blue;
                            margin-left: 5px;
                        }
                    </style>
                </div>
            </div>
        </div>
    </div>
    </div>
    </div>
    </div>
    </div>
    </div>
    <!-- Background Settings Modal -->
    <div id="backgroundSettingsModal" class="modal">
        <div class="modal-content">
            <span id="closeModal" style="float:right;cursor:pointer;">&times;</span>
            <input type="color" id="backgroundColorPicker" value="#ffffff">
            <br><br>

            <input type="file" id="backgroundImageInput" accept="image/*" multiple>
            <div id="backgroundImageGallery" style="display: flex; flex-wrap: wrap; margin-top: 10px;"></div>
            <div id="backgroundPreview"
                style="display: none; position: absolute; z-index: 1000; border: 2px solid #000;"></div>
        </div>
    </div>
    <!-- Canvas Settings Modal -->
    <div id="canvasSettingsModal" class="modal">
        <div class="modal-content">
            <span id="closeCanvasModal" style="float:right;cursor:pointer;">&times;</span>
            <input type="color" id="canvasColorPicker" value="#00">
            <br><br>
            <input type="file" id="canvasImageInput" accept="image/*">
            <div id="canvasImageGallery" style="display: flex; flex-wrap: wrap; margin-top: 10px;"></div>
        </div>
    </div>
    <style>
        #zoomLevelDisplay {
            color: red;
            font-weight: bold;
            font-size: 16px;
            margin-top: 10px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
        }

        .modal-content {
            background-color: #4b0000;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
        }
    </style>
<style>
/* –∏–∫–æ–Ω–∫–∞ —Ä—è–¥–æ–º —Å–æ —Å–ª–æ—è–º–∏ */
    .eye-icon {
        margin-left: 5px;
        font-size: 0.8em;
    }
</style>
<script>
// –¥–æ–±–∞–≤–ª–µ–Ω–æ 22 Sep 19:05
document.querySelectorAll('button').forEach(button => {
    button.addEventListener('contextmenu', (event) => {
        event.preventDefault(); // Prevent the default context menu
        // Your custom context menu logic here
        console.log(`Context menu for ${button.title}`);
    });
});

    // –°–æ–∑–¥–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç color input, –µ—Å–ª–∏ –µ–≥–æ –µ—â–µ –Ω–µ—Ç
    let colorPicker = $('dynamicColorPicker');
    if (!colorPicker) {
      colorPicker = document.createElement('input');
      colorPicker.type = 'color';
      colorPicker.id = 'dynamicColorPicker';
      colorPicker.style.position = 'absolute';
      colorPicker.style.display = 'block';
      document.body.appendChild(colorPicker);
    }

    // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º color picker —Ä—è–¥–æ–º —Å –∫–Ω–æ–ø–∫–æ–π
    colorPicker.style.left = `${event.pageX}px`;
    colorPicker.style.top = `${event.pageY}px`;
    colorPicker.style.display = 'block';

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ü–≤–µ—Ç –∫–∏—Å—Ç–∏ –ø—Ä–∏ –≤—ã–±–æ—Ä–µ —Ü–≤–µ—Ç–∞
    colorPicker.oninput = function() {
      setBrushColor(this.value); // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç—Å—è, —á—Ç–æ —É –≤–∞—Å –µ—Å—Ç—å —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Ü–≤–µ—Ç–∞ –∫–∏—Å—Ç–∏
    };

// –°–∫—Ä—ã–≤–∞–µ–º color picker –ø—Ä–∏ –∫–ª–∏–∫–µ –≤ –ª—é–±–æ–º –º–µ—Å—Ç–µ
document.addEventListener('click', () => {
  const colorPicker = $('dynamicColorPicker');
  if (colorPicker) {
    colorPicker.style.display = 'none';
  }
});</script>
<script>

</script>
<script>
function setLayerBackground(layerIndex) {
  const color = $('backgroundPicker').value;
  contexts[layerIndex].fillStyle = color;
  contexts[layerIndex].fillRect(0, 0, layers[layerIndex].width, layers[layerIndex].height);
}

backgroundPicker.addEventListener('input', (event) => {
  setLayerBackground(currentLayer); 
});
</script>
    <script>
        const layerCreationComplete = new Event('layerCreationComplete');

        const elements = ['UploadB', 'fillModeBtn',
            'brushSize', 'opacity', 'pressureBar', 'backgroundPicker',
            'addLayerBtn', 'removeLayerBtn', 'eraserBtn', 'layerButtons',
            'zoomBtn', 'canvasContainer', 'drawOnExistingBtn', 'identifyLayerBtn', 'layerOpacitySlider', 'layerOpacityValue',
        ];

        const container = $('canvasContainer');
        const containerRect = container.getBoundingClientRect();
        const obj = Object.fromEntries(
            elements.map(id => [id, $(id)])
        );
        const layerPanel = document.querySelector('.layer-panel'),
            sidebar = document.querySelector(".sidebar"),
            layerOpacities = {},
            layers = [],
            contexts = {},
            layerColors = [],
            history = {},
            points = [],
            redoHistory = [];

        const MAX_ZOOM = 100, MIN_ZOOM = 1, ZOOM_STEP = 0.02;

        let layerCount = 0,
            symmetry = true,
            currentLayer = 1,
            previousLayer = 1,

            isSpider = false,

            curCtx,
            isDrawing = false,
            isErasing = false,
            isDrawOnExisting = false,
            zoomLevel = 1, // 1000% = 10
            isIdentifyingLayer = false,
            wasDrawing = false,
            isDraggingScroll = false,
            startY,
            currentCursor = 'auto',
            isZoomActive = false,
            offsetX = 0,
            offsetY = 0,
            lastX = null,
            lastY = null,
            uploadedImage = null,
            clearedCanvasState = null,
            isFillMode = false,
            zoomOriginX = 0,
            zoomOriginY = 0,
            isSmoothLineMode = false,
            isCtrlPressed = false;




    </script>
    <script>

    </script>
    <script>




        const symmetryButton = $('symmetry');

        symmetryButton.addEventListener('click', toggleSymmetry);
        // !
        function toggleSymmetry() {
            symmetry = !symmetry;
            if (symmetry) {
                symmetryButton.classList.add('active');
            } else {
                symmetryButton.classList.remove('active');
            }
        }

        function toggleDrawOnExisting() {
            isDrawOnExisting = !isDrawOnExisting;
            drawOnExistingBtn.classList.toggle('active', isDrawOnExisting);
        }</script>
    <script>
        const spiderStrengthSlider = $('spiderStrength');

        function toggleSpider() {
            isSpider = !isSpider;
            spider.classList.toggle('active', isSpider);
            // Show or hide the slider based on the spider tool state
            spiderStrengthSlider.style.display = isSpider ? 'block' : 'none';
        }

        function drawSpider(startX, startY, endX, endY) {
            curCtx.globalAlpha = 1; // Set opacity
            curCtx.lineJoin = 'round'; // Rounded corners
            curCtx.lineCap = 'round'; // Rounded line ends

            curCtx.beginPath();
            curCtx.moveTo(startX, startY);
            curCtx.quadraticCurveTo(startX, startY, endX, endY);
            curCtx.stroke();

            points.push({ x: endX, y: endY }); // Store the current point

            // Use the slider value for power
            var power = spiderStrengthSlider.value;

            for (let i = 0; i < points.length; i++) {
                const dx = points[i].x - endX;
                const dy = points[i].y - endY;
                const dd = dx * dx + dy * dy;
                if (dd < power) {
                    curCtx.beginPath();
                    curCtx.moveTo(endX + (dx * 0.2), endY + (dy * 0.2));
                    curCtx.lineTo(points[i].x - (dx * 0.2), points[i].y - (dy * 0.2));
                    curCtx.stroke();
                }
            }
        }

        $('spider').addEventListener('click', toggleSpider);
    </script>
    </script>
    <script>

        document.dispatchEvent(layerCreationComplete);
        // Object.values(layers).forEach(addEventListenersToLayer);
        drawOnExistingBtn.addEventListener('click', toggleDrawOnExisting);

// –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø 
        document.addEventListener('DOMContentLoaded', function () {

            initializeApp();
        });

        function initializeApp() {
            createLayer();
        }

// —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –±—ç–∫–≥—Ä–∞—É–Ω–¥–∞
        function setLayerBackground(layerIndex, imageUrl) {
            const img = new Image();
            img.onload = function () {
                contexts[layerIndex].drawImage(img, 0, 0, layers[layerIndex].width, layers[layerIndex].height);
            }
            img.src = imageUrl;
        }
// —Å–æ–∑–¥–∞–Ω–∏–µ —Å–ª–æ–µ–≤
        function createLayer() {

            updateZoom();
            if (!layers[100]) {
                const canvas = document.createElement('canvas');
                canvas.width = 600;
                canvas.height = 400;
                canvas.style.position = 'absolute';
                canvasContainer.appendChild(canvas);
                layers[0] = canvas;
                contexts[0] = canvas.getContext('2d');
                setLayerBackground(100, 'images/canvas1.jpg');
            }

            layerCount++;
            layerColors[layerCount] = '#' + Math.floor(Math.random() * 16777215).toString(16);
            const canvas = document.createElement('canvas');
            canvas.id = `layer${layerCount}`;
            canvas.width = 600;
            canvas.height = 400;
            canvas.style.position = 'absolute';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.zIndex = layerCount;
            canvasContainer.appendChild(canvas);
            layers[layerCount] = canvas;
            contexts[layerCount] = canvas.getContext('2d');
            const button = document.createElement('button');
            button.textContent = " ‚ù§ ";
            button.classList.add('layer-button');
            button.dataset.layer = layerCount;


            // Add eye icon
            const eyeIcon = document.createElement('span');
            eyeIcon.textContent = "üëÅÔ∏è";
            eyeIcon.style.display = 'none';
            eyeIcon.classList.add('eye-icon');
            button.appendChild(eyeIcon);


            layerButtons.appendChild(button);
            button.addEventListener('click', function () {
                setCurrentLayer(parseInt(this.dataset.layer));
            });
            addEventListenersToLayer(canvas);
            setCurrentLayer(layerCount);
            initializeLayer(layerCount);
            history[layerCount] = [];
            redoHistory[layerCount] = [];
            updateLayerButtonColor(layerCount);
            updateLayerOrder();
            createHistorySlider(layerCount);
            layerDrawnOn[layerCount] = false; // Initialize as not drawn on

        }
// —É—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç–µ–∫—É—â–µ–≥–æ —Å–ª–æ—è
        function setCurrentLayer(layerNum) {
            if (layerNum === 100) {
                return;
            }
            if (!layers[layerNum] || !contexts[layerNum]) {
                console.warn(`Layer ${layerNum} does not exist. Cannot set as current layer.`);
                return;
            }

            if (currentLayer !== layerNum) {
                previousLayer = currentLayer;
            }

            currentLayer = layerNum;
            curCtx = contexts[currentLayer];

            const opacity = layerOpacities[layerNum] || 100;
            layerOpacitySlider.value = opacity;
            layerOpacityValue.textContent = opacity;

            document.querySelectorAll('.layer-button').forEach(btn => {
                btn.classList.remove('active-layer');
                if (parseInt(btn.dataset.layer) === currentLayer) {
                    btn.classList.add('active-layer');
                }
            });

            if (!isErasing) {
                updateLayerButtonColor(layerNum);
            }

            if (layerColors[layerNum]) {
                curCtx.strokeStyle = layerColors[layerNum];
            }
            // –æ–±–Ω–æ–≤–ª—è–µ–º –∏–∫–æ–Ω–∫—É —Ç—É—Ç
            updateLayerEyeIcon(layerNum);

        }
// –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞ —Å–ª–æ–µ–≤
        function updateLayerButtonColor(layerNum) {
            const button = document.querySelector(`.layer-button[data-layer="${layerNum}"]`);
            if (button && layerColors[layerNum]) {
                button.style.backgroundColor = layerColors[layerNum];
            }
        }
// –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–ª–æ—è(–Ω—É–∂–Ω–æ —Ç–∞–∫ –∂–µ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –Ω–æ–≤–æ–≥–æ —Å–ª–æ—è)
        function initializeLayer(layerNum) {

            contexts[layerNum].fillStyle = 'rgba(0,0,0,0)';
            contexts[layerNum].fillRect(0, 0, layers[layerNum].width, layers[layerNum].height);
        }

// —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏
        function saveState() {
            if (!curCtx) {
                return;
            }

            if (history[currentLayer].length >= MAX_HISTORY_STATES) {
                history[currentLayer].shift();
            }

            history[currentLayer].push(curCtx.getImageData(0, 0, layers[currentLayer].width, layers[currentLayer].height));
            redoHistory[currentLayer] = [];

            historySlider.max = history[currentLayer].length - 1;
            historySlider.value = history[currentLayer].length - 1;
        }

// –ø—Ä–æ—Ü–µ—Å—Å —Ä–∏—Å–æ–≤–∞–Ω–∏—è startDrawing draw
        function startDrawing(e) {
            if (currentLayer === 100 || !curCtx || isEyedropperActive || isCtrlPressed) {
                return;
            }
            isDrawing = true;
            const rect = layers[currentLayer].getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / zoomLevel);
            const y = Math.floor((e.clientY - rect.top) / zoomLevel);

            points.length = 0;
            points.push({ x, y });

            [lastX, lastY] = [x, y];
            saveState();
        }

        function draw(e) {
            if (!isDrawing || !curCtx) {
                return;
            }
            if (isFinger) {
                fingerfunc(e);
                return;
            }
            const rect = layers[currentLayer].getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / zoomLevel);
            const y = Math.floor((e.clientY - rect.top) / zoomLevel);
            const pressure = e.pressure || 1;
            curCtx.lineWidth = brushSize.value * pressure;
            curCtx.lineCap = 'round';
            curCtx.lineJoin = 'round';
            curCtx.globalAlpha = opacity.value / 100;
            curCtx.globalCompositeOperation = isErasing ? 'destination-out' : 'source-over';

            if (isSpider) {
                drawSpider(lastX, lastY, x, y);
            } else {
                if (isDrawOnExisting) {
                    tools.drawOn(lastX, lastY, x, y, curCtx);
                } else {
                    curCtx.beginPath();
                    curCtx.moveTo(lastX, lastY);
                    curCtx.lineTo(x, y);
                    curCtx.stroke();
                }
            }

            if (symmetry) {
                const centerX = layers[currentLayer].width / 2;
                const symmetricLastX = centerX + (centerX - lastX);
                const symmetricX = centerX + (centerX - x);

                if (isSpider) {
                    drawSpider(symmetricLastX, lastY, symmetricX, y);
                } else {
                    if (isDrawOnExisting) {
                        tools.drawOn(symmetricLastX, lastY, symmetricX, y, curCtx);
                    } else {
                        curCtx.beginPath();
                        curCtx.moveTo(symmetricLastX, lastY);
                        curCtx.lineTo(symmetricX, y);
                        curCtx.stroke();
                    }
                }
            }

            [lastX, lastY] = [x, y];
            pressureBar.value = pressure * 10000;
            pressureBar.nextElementSibling.textContent = Math.round(pressure * 100);
            // add –∏–∫–æ–Ω–∫–∞ –≥–ª–∞–∑–∞ –¥–ª—è —Å–ª–æ–µ–≤
            layerDrawnOn[currentLayer] = true;
            updateLayerEyeIcon(currentLayer);
            }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                saveState();
                points.length = 0;
            }
            lastX = null;
            lastY = null;
        }

        function endDrawing() {
            if (isDrawing) {
                isDrawing = false;
                lastX = null;
                lastY = null;
            }
        }

        function addEventListenersToLayer(layer) {
            layer.addEventListener('pointerdown', startDrawing);
            layer.addEventListener('pointermove', draw);
            layer.addEventListener('pointerup', endDrawing);
        }











    </script> 
<script>
// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è —Å–ª–æ–µ–≤
// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è —Å–ª–æ–µ–≤
function mergeLayers() {
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —Ö–æ–ª—Å—Ç –¥–ª—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    const mergedCanvas = document.createElement('canvas');
    const mergedCtx = mergedCanvas.getContext('2d');
    mergedCanvas.width = layers[1].width;
    mergedCanvas.height = layers[1].height;

    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∫–Ω–æ–ø–∫–∏ —Å–ª–æ–µ–≤ –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –∏—Ö –ø–æ z-index
    const layerButtons = Array.from(document.querySelectorAll('.layer-button'));
    layerButtons.sort((a, b) => {
        const layerA = layers[parseInt(a.dataset.layer)];
        const layerB = layers[parseInt(b.dataset.layer)];
        return parseInt(layerA.style.zIndex || 0) - parseInt(layerB.style.zIndex || 0);
    });

    // –†–∏—Å—É–µ–º –∫–∞–∂–¥—ã–π —Å–ª–æ–π –Ω–∞ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–Ω–æ–º —Ö–æ–ª—Å—Ç–µ
    layerButtons.forEach((button) => {
        const layerId = parseInt(button.dataset.layer);
        if (layers[layerId] && layerId !== 100) { // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º 100-–π —Å–ª–æ–π
            mergedCtx.drawImage(layers[layerId], 0, 0);
            // –û—á–∏—â–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å–ª–æ—è, –∫—Ä–æ–º–µ —Ç–µ–∫—É—â–µ–≥–æ
            if (layerId !== currentLayer) {
                const ctx = contexts[layerId];
                ctx.clearRect(0, 0, layers[layerId].width, layers[layerId].height);
            }
        }
    });

    // –†–∏—Å—É–µ–º –æ–±—ä–µ–¥–∏–Ω–µ–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–∞ —Ç–µ–∫—É—â–µ–º —Å–ª–æ–µ
    curCtx.drawImage(mergedCanvas, 0, 0);

    // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
    updateLayerOrder();
    setCurrentLayer(1);
}
</script>
    <script>
// –ø–∏–ø–µ—Ç–∫–∞ 
        canvasContainer.addEventListener('click', handleEyedropperClick);
        canvasContainer.addEventListener('touchstart', handleEyedropperClick);

        const eyedropperBtn = $('eyedropperBtn');
        let isEyedropperActive = false;

        eyedropperBtn.addEventListener('click', handleEyedropperActivation);
        eyedropperBtn.addEventListener('touchstart', handleEyedropperActivation);

        function handleEyedropperActivation(e) {
            e.preventDefault();

            isEyedropperActive = !isEyedropperActive;
            document.body.style.cursor = isEyedropperActive ? 'url(cursors/pipette.png), auto' : 'auto';
            eyedropperBtn.classList.toggle('active');

            if (isEyedropperActive) {
                isDrawing = false;
            }
        }


        function handleEyedropperClick(e) {
            if (!isEyedropperActive) return;
            isDrawing = false;
            e.preventDefault();
            const rect = canvasContainer.getBoundingClientRect();
            const x = Math.floor((e.clientX || e.touches[0].clientX - rect.left) / zoomLevel);
            const y = Math.floor((e.clientY || e.touches[0].clientY - rect.top) / zoomLevel);

            // –ü–æ–ª—É—á–∞–µ–º z-index (–æ—Ç –±–æ–ª—å—à–µ–≥–æ –∫ –º–µ–Ω—å—à–µ–º—É)
            const sortedLayers = Object.keys(layers)
                // .filter(key => key !== '100' && key !== '0') // –ò—Å–∫–ª—é—á–∞–µ–º —Ñ–æ–Ω–æ–≤—ã–π —Å–ª–æ–π –∏ —Å–ª–æ–π 0
                .filter(key => key !== '100') // –ò—Å–∫–ª—é—á–∞–µ–º —Ñ–æ–Ω–æ–≤—ã–π —Å–ª–æ–π
                .sort((a, b) => parseInt(layers[b].style.zIndex) - parseInt(layers[a].style.zIndex));

            for (let i = 0; i < sortedLayers.length; i++) {
                const layerId = sortedLayers[i];
                const ctx = contexts[layerId];
                const imageData = ctx.getImageData(x, y, 1, 1);
                const [r, g, b, a] = imageData.data;
                if (a > 0) {
                    const color = `rgba(${r},${g},${b},${a / 255})`;
                    // Update the layer button color
                    const layerButton = document.querySelector(`.layer-button[data-layer="${currentLayer}"]`);
                    if (layerButton) {
                        layerButton.style.backgroundColor = color;
                    }
                    curCtx.strokeStyle = color;
                    isEyedropperActive = false;
                    eyedropperBtn.classList.remove('active');
                    return;
                }
            }

            // –ï—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω –Ω–µ–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π –ø–∏–∫—Å–µ–ª—å –Ω–∞ –≤—Å–µ—Ö —Å–ª–æ—è—Ö
            isEyedropperActive = false;
            document.body.style.cursor = 'auto';
            eyedropperBtn.classList.remove('active');
        }

        // –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å —Å–ª–æ–µ–≤
        function togglePreviousLayer() {
            [currentLayer, previousLayer] = [previousLayer, currentLayer];
            const layerButton = document.querySelector(`.layer-button[data-layer="${currentLayer}"]`);
            if (layerButton) {
                layerButton.click();
            }
        }

        // –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Å–ª–æ—è
        canvasContainer.addEventListener('click', (e) => {
            if (isIdentifyingLayer) {
                identifyLayerClickHandler(e);
                canvasContainer.style.cursor = 'default';
                isDrawing = wasDrawing;
                isIdentifyingLayer = false;
                identifyLayerBtn.classList.remove('active');
            }
        });
        // –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Å–ª–æ—è
        identifyLayerBtn.addEventListener('click', () => {
            isIdentifyingLayer = !isIdentifyingLayer;
            identifyLayerBtn.classList.toggle('active', isIdentifyingLayer);
            if (isIdentifyingLayer) {
                wasDrawing = isDrawing;
                isDrawing = false;
                canvasContainer.style.cursor = 'crosshair';
            } else {
                canvasContainer.style.cursor = 'auto';
                isDrawing = wasDrawing;
            }
        });
        function identifyLayerClickHandler(e) {
            const rect = layers[1].getBoundingClientRect();
            const x = (e.clientX - rect.left) / zoomLevel;
            const y = (e.clientY - rect.top) / zoomLevel;

            // Start from the bottom layer (lowest z-index), excluding background layer
            for (let i = 1; i <= layerCount; i++) {
                if (i === 100) continue; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–ª–æ–π 100 (–±—ç–∫–≥—Ä–∞—É–Ω–¥)
                const ctx = contexts[i];
                const pixelData = ctx.getImageData(x, y, 1, 1).data;
                // If a pixel is found on this layer (alpha > 0)
                if (pixelData[3] > 0) {
                    setCurrentLayer(i);
                    updateLayerButtonColor(i);
                    return;
                }
            }
        }
        // —Å–æ–∫—Ä–∞—Ç–∏—Ç—å
        layerPanel.addEventListener("pointerenter", (e) => {
            e.preventDefault();
            isDraggingScroll = true;
            startY = e.clientY;
        });
        sidebar.addEventListener("pointerenter", (e) => {
            e.preventDefault();
            isDraggingScroll = true;
            startY = e.clientY;
        });
        sidebar.addEventListener('pointermove', (e) => {
            if (isDraggingScroll) {
                const deltaY = e.clientY - startY;
                sidebar.scrollTop += deltaY;
                startY = e.clientY;
            }
        });
        layerPanel.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            isDraggingScroll = true;
            startY = e.clientY;
        });

        layerPanel.addEventListener('pointermove', (e) => {
            if (isDraggingScroll) {
                const deltaY = e.clientY - startY;
                layerPanel.scrollTop += deltaY;
                startY = e.clientY;
            }
        });
        // added 21 Sep 15:14
        // function isPointInsideCanvas(x, y) {
        //     const canvasRect = canvasContainer.getBoundingClientRect();
        //     return (
        //         x >= canvasRect.left &&
        //         x <= canvasRect.right &&
        //         y >= canvasRect.top &&
        //         y <= canvasRect.bottom
        //     );
        // }

        // function handlePointerUp(e) {
        //     const rect = layers[currentLayer].getBoundingClientRect();
        //     const x = (e.clientX - rect.left) / zoomLevel;
        //     const y = (e.clientY - rect.top) / zoomLevel;

        //     if (!isPointInsideCanvas(e.clientX, e.clientY)) {
        //         endDrawing();
        //     }
        // }

        // function handlePointerOut(e) {
        //     const rect = layers[currentLayer].getBoundingClientRect();
        //     const x = (e.clientX - rect.left) / zoomLevel;
        //     const y = (e.clientY - rect.top) / zoomLevel;

        //     if (!isPointInsideCanvas(e.clientX, e.clientY)) {
        //         endDrawing();
        //     }
        // }

        // // –ó–∞–º–µ–Ω–∏—Ç–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –Ω–∞ –Ω–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
        // layer.addEventListener('pointerup', handlePointerUp);
        // layer.addEventListener('pointerout', handlePointerOut);

        // layerPanel.addEventListener('pointerup', () => {

        //  });
        canvasContainer.addEventListener('pointerdown', handleCanvasClick);
        function handleCanvasClick(e) {
            if (e.altKey) {
                isDrawing = false;
                e.preventDefault();
                identifyLayerClickHandler(e);
            }
        }
function updateLayerOrder() {
    const layerButtons = Array.from(document.querySelectorAll('.layer-button'));
    layerButtons.forEach((button, index) => {
        const layerId = parseInt(button.dataset.layer);
        if (layers[layerId]) { 
            if (layerId === 100) { // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å–ª–æ–π —Ñ–æ–Ω–æ–≤—ã–º
                layers[layerId].style.zIndex = -100; // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º z-index –¥–ª—è —Ñ–æ–Ω–∞
            } else {
                layers[layerId].style.zIndex = layerButtons.length - index + 110; 
            }
        }
    });
}

// function updateLayerOrder() {
//             const layerButtons = Array.from(document.querySelectorAll('.layer-button'));
//             layerButtons.forEach((button, index) => {
//                 const layerId = parseInt(button.dataset.layer);
//                 if (layers[layerId] && layerId !== 0) {
//                     layers[layerId].style.zIndex = layerButtons.length - index + 110; // +110 —á—Ç–æ–±—ã –±—ã—Ç—å –≤—ã—à–µ —Ñ–æ–Ω–∞
//                 }
//             });
//         }

// –¥–≤–∏–≥–∞–µ–º —Å–ª–æ–∏ –∫–Ω–æ–ø–∫–∞–º–∏
        const moveLayerUpBtn = $('moveLayerUp');
        const moveLayerDownBtn = $('moveLayerDown');
        moveLayerUpBtn.addEventListener('click', () => {
            moveLayerInStack(-1);
        });
        moveLayerDownBtn.addEventListener('click', () => {
            moveLayerInStack(1);
        });
        function moveLayerInStack(direction) {
            const currentLayerButton = document.querySelector(`.layer-button[data-layer="${currentLayer}"]`);
            const targetLayerButton = direction === -1 ? currentLayerButton.previousElementSibling : currentLayerButton
                .nextElementSibling;
            if (targetLayerButton) {
                if (direction === -1) {
                    currentLayerButton.parentNode.insertBefore(currentLayerButton, targetLayerButton);
                } else {
                    currentLayerButton.parentNode.insertBefore(targetLayerButton, currentLayerButton);
                }
                updateLayerOrder();
                currentLayerButton.click();
            }
        }
        const layerButtonsContainer = $('layerButtons');
        // Zoom functions
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Control') {
                isCtrlPressed = true;
            }
            // fix
            lastX = null;
            lastY = null;
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'Control') {
                isCtrlPressed = false;
                // fix —Å–±—Ä—Ä–æ—Å
                lastX = null;
                lastY = null;
            }
        });



        canvasContainer.addEventListener('mousemove', (e) => {
            e.preventDefault();
            if (isEyedropperActive || !isCtrlPressed || isDrawing || isFinger) return;



            const rect = canvasContainer.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (lastX !== undefined) {
                const deltaX = e.movementX;
                const oldZoom = zoomLevel;
                zoomLevel = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, zoomLevel + deltaX * ZOOM_STEP));

                if (oldZoom !== zoomLevel) {
                    zoomOriginX = (mouseX - offsetX) / oldZoom;
                    zoomOriginY = (mouseY - offsetY) / oldZoom;

                    offsetX = mouseX - zoomOriginX * zoomLevel;
                    offsetY = mouseY - zoomOriginY * zoomLevel;

                    updateZoom();
                }
            }

            lastX = mouseX;
            lastY = mouseY;
        });




        function updateZoom() {


            Object.values(layers).forEach(layer => {

                layer.style.transformOrigin = '0 0';

                if (zoomLevel <= 1) {
                    offsetX = 0;
                    offsetY = 0;
                    layer.style.transform = `scale(${zoomLevel})`;
                    layer.style.left = '0';
                    layer.style.top = '0';
                } else {
                    layer.style.transform = `scale(${zoomLevel})`;

                    const layerRect = layer.getBoundingClientRect();
                    offsetX = Math.min(Math.max(offsetX, containerRect.width - layerRect.width), 0);
                    offsetY = Math.min(Math.max(offsetY, containerRect.height - layerRect.height), 0);

                    layer.style.left = `${offsetX}px`;
                    layer.style.top = `${offsetY}px`;
                }
            });

            canvasContainer.style.overflow = 'hidden';
            // –∏–∫–æ–Ω–∫–∞ –∏ –∑—É–º –≤ html
            $('zoomLevelDisplay').textContent = `üîé${(zoomLevel * 100).toFixed(0)}%`;
        }


    </script>
    <script src="script.js" defer></script>
    <script src="cursors.js" defer></script>
    <script type="module" src="constants.js" defer></script>
    <script type="module" src="main.js" defer></script>
    <script type="module" src="test.js" defer></script>
    <script type="module" src="settings.js" defer></script>
    <script type="module" src="helperFunction.js" defer></script>
    <script type="module" src="listners.js" defer></script>
    <script type="module" src="buttons.js" defer></script>
    <script type="module" src="hotkey.js" defer></script>
    <script type="module" src="settingsPanel.js" defer></script>
    <script type="module" src="tools.js" defer></script>

    <script>


        //  –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –ø–∞–ª–µ—Ü
        let isFinger = false;

        const narrowToCenterBtn = $('fingerfunc');

        narrowToCenterBtn.addEventListener('click', () => {
            isFinger = !isFinger;
            narrowToCenterBtn.classList.toggle('active', isFinger);
        });
        function fingerfunc(e) {
            if (!isDrawing || !curCtx || !isFinger) return;

            const rect = layers[currentLayer].getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / zoomLevel);
            const y = Math.floor((e.clientY - rect.top) / zoomLevel);

            const brushSize = parseInt(brushSize.value);
            const halfBrushSize = brushSize / 2;

            curCtx.save();
            curCtx.beginPath();
            curCtx.arc(x, y, halfBrushSize, 0, Math.PI * 2);
            curCtx.clip();

            if (lastX !== null && lastY !== null) {
                const dx = x - lastX;
                const dy = y - lastY;
                curCtx.drawImage(
                    layers[currentLayer],
                    x - halfBrushSize - dx, y - halfBrushSize - dy, brushSize, brushSize,
                    x - halfBrushSize, y - halfBrushSize, brushSize, brushSize
                );
            }

            curCtx.restore();

            lastX = x;
            lastY = y;
        }
        // —Å–ª–∞–π–¥–µ—Ä –∏—Å—Ç–æ—Ä–∏–∏

        function resetOriginalImage(layerNum) {
            delete originalImages[layerNum];

        }

        const historySliders = {};
        let currentHistorySlider;
        const MAX_HISTORY_STATES = 50;

        function createHistorySlider() {
            const sliderContainer = document.createElement('div');
            sliderContainer.classList.add('history-slider-container');

            const label = document.createElement('label');
            sliderContainer.appendChild(label);

            historySlider = document.createElement('input');
            historySlider.type = 'range';
            historySlider.min = '0';
            historySlider.max = '0';
            historySlider.value = '0';
            historySlider.classList.add('history-slider');
            sliderContainer.appendChild(historySlider);

            historySlider.addEventListener('input', function () {
                restoreLayerState(currentLayer, parseInt(this.value)); // Restore state for the current layer
            });
        }



        // –æ–±–≤–æ–¥–∫–∞

        const originalImages = {};
        const outlineSizes = {};

        const outlineSizeInput = $('outlineSize');
        const outlineSizeValue = $('outlineSizeValue');

        outlineSizeInput.max = "5";

        outlineSizeInput.addEventListener('input', function () {
            // –°–±—Ä–æ—Å –≤—Å–µ—Ö –æ–±–≤–æ–¥–æ–∫
            Object.keys(layers).forEach(key => {
                const layer = layers[key];
                const layerCtx = contexts[key];
                if (originalImages[key]) {
                    layerCtx.putImageData(originalImages[key], 0, 0);
                }
            });

            const size = parseInt(this.value);
            outlineSizeValue.textContent = size;
            applyOutline(currentLayer, size);
        });

        function applyOutline(layerNum, size) {


            if (!layers[layerNum] || !contexts[layerNum]) {
                return;
            }
            const canvas = layers[layerNum];
            const ctx = contexts[layerNum];

            // RESET OUTLINE BEFORE APPLYING NEW ONE
            if (!originalImages[layerNum]) {
                originalImages[layerNum] = ctx.getImageData(0, 0, canvas.width, canvas.height);
            } else {
                ctx.putImageData(originalImages[layerNum], 0, 0); // Restore to original before applying new outline
            }

            outlineSizes[layerNum] = size;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–ª–æ—è –≤–º–µ—Å—Ç–æ originalImages
            tempCtx.drawImage(canvas, 0, 0);
            tempCtx.putImageData(originalImages[layerNum], 0, 0);

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (size === 0) {
                ctx.putImageData(originalImages[layerNum], 0, 0);
                return; // Exit if size is 0
            }

            const originalStrokeStyle = ctx.strokeStyle;

            ctx.lineWidth = size;
            ctx.strokeStyle = 'black';
            const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const index = (y * canvas.width + x) * 4;
                    if (data[index + 3] > 0) {
                        ctx.beginPath();
                        ctx.arc(x, y, size / 2, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
            }

            ctx.drawImage(tempCanvas, 0, 0);
            ctx.strokeStyle = originalStrokeStyle;
        }



        function updateOutlineForLayer(layerNum) {

            if (!layers[layerNum] || !contexts[layerNum]) {
                console.warn(`Layer ${layerNum} does not exist. Skipping outline update.`);
                return;
            }

            const size = outlineSizes[layerNum] || 0;
            outlineSizeInput.value = size;
            outlineSizeValue.textContent = size;
            applyOutline(layerNum, size);

        }
    </script>
    <script>
        // !?
        // document.querySelectorAll('button, input').forEach(element => {
        //      element.addEventListener('pointerdown', (e) => {
        //          e.stopPropagation();
        //      });
        //   });


    </script>
    <script>
// –¥–æ–±–∞–≤–ª—è–µ–º –∏–∫–æ–Ω–∫—É –∑–∞–¥–µ–π—Å—Ç–≤–æ–≤–∞–Ω–Ω—ã—Ö —Å–ª–æ–µ–≤
    const layerDrawnOn = {};
    function updateLayerEyeIcon(layerNum) {
        const layerButton = document.querySelector(`.layer-button[data-layer="${layerNum}"]`);
        if (layerButton) {
            const eyeIcon = layerButton.querySelector('.eye-icon');
            if (eyeIcon) {
                eyeIcon.style.display = layerDrawnOn[layerNum] ? 'inline' : 'none';
            }
        }
    }
// —Å–æ–æ–±—â–µ–Ω–∏–µ
    const messageButton = $('message');
    const messageContainer = $('message-container');
    const messageText = $('message-text'); 

    function showMessage(message) {
      messageText.textContent = message; 
      messageContainer.style.display = 'block'; 
    }

    messageButton.addEventListener('click', () => {
      showMessage("–ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ."); // Show a test message
    });

    if (!messageContainer.querySelector('.close-button')) {
      const closeButton = document.createElement('span');
      closeButton.textContent = '√ó';
      closeButton.classList.add('close-button');
      messageContainer.appendChild(closeButton);

      closeButton.addEventListener('click', () => {
        messageContainer.style.display = 'none';
      });
    }

    window.addEventListener('click', (event) => {
      if (event.target === messageContainer) {
        messageContainer.style.display = 'none';
      }
    });

    </script>
    </script>
</body>

</html>