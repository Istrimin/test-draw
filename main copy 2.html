<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ù–∞—Å—Ç–æ—è—â–∏–π –•—É–¥–æ–∂–Ω–∏–∫</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jscolor/2.4.5/jscolor.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>


    </head>
<style>
 #zoomLevelDisplay {
    color: red; /* Set text color to red */
    font-weight: bold; /* Make the text bold */
    font-size: 16px; /* Adjust font size */
    margin-top: 10px; 
 }
/* –ø–æ—Ñ–∏–∫—Å–∏—Ç—å –ø–∞–Ω–µ–ª—å –∫—É—Ä—Å–æ—Ä–æ–≤ –¥–ª—è –ø–ª–∞–Ω—à–µ—Ç–∞ */

    </style>
<body>
    <div class="base-container">
        <div class="sidebar">
            <a href="index.html" target="_self" title="–í—ã–π—Ç–∏ –∏–∑ –∫–æ–º–∞–Ω—Ç—ã" id="exitLink">üö™</a>
            <button id="message" title="–°–æ–æ–±—â–µ–Ω–∏–µ">‚úâÔ∏è</button>
            <div id="message-container" style="display: none;">
                <p id="message"></p>
             </div>
            <button id="identifyLayerBtn" title="–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å–ª–æ–π">üîç</button>
            <button id="drawUnderExistingBtn" title="–†–∏—Å–æ–≤–∞—Ç—å –ø–æ–¥ –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω–Ω—ã–º">‚û°Ô∏è</button>
            <button id="drawOnExistingBtn" title="–†–∏—Å–æ–≤–∞—Ç—å –Ω–∞ –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω–Ω–æ–º">On</button>

            <input type="file" id="imageInput" accept="image/*" style="display: none;">
            <button id="UploadButton" title="–ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (U)">üå∫</button>
            <button id="saveImageBtn" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ">üé¨</button>
            <button id="eraserBtn">üßΩ</button>
            <button id="changeCursorBtn" title="–°–º–µ–Ω–∏—Ç—å –∫—É—Ä—Å–æ—Ä">üé®</button>
            <button id="undoBtn" title="–û—Ç–º–µ–Ω–∏—Ç—å (Z)">‚ü≤</button>
            <button id="redoBtn" title="–ü–æ–≤—Ç–æ—Ä–∏—Ç—å (X)">‚ü≥</button>
            <button id="clear" title="–û—á–∏—Å—Ç–∏—Ç—å">üíÄ</button>
            <button id="fillModeBtn" title="–ó–∞–ª–∏–≤–∫–∞ (F)">üåä</button>
            <button id="floodFillBtn" title="–ó–∞–ª–∏—Ç—å —Ü–≤–µ—Ç–æ–º">‚ú®</button>
            <button id="eyedropperBtn" title="–ü–∏–ø–µ—Ç–∫–∞ –∑–∞–ª–∏–≤–∫–∏ (A)">üíß</button>
            <button id="brushEyedropperBtn" title="–ü–∏–ø–µ—Ç–∫–∞ –∫–∏—Å—Ç–∏ (D)">üñåÔ∏è</button>
            <button id="deleteAllBtn" title="–£–¥–∞–ª–∏—Ç—å –≤—Å–µ">üóëÔ∏è</button>

            <button id="mergeLayers" title="–û–±—ä–µ–¥–∏–Ω–∏—Ç—å —Å–ª–æ–∏">üîó</button>
            <button id="settings" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏">‚öôÔ∏è</button>
          </div>
       <div class="canvas-and-sliders">
            <div class="layer-panel-wrapper">

                <button id="moveLayerUp" title="–°–ª–æ–π –≤–≤–µ—Ä—Ö">‚ñ≤</button>
                <div class="layer-panel">
                    <div id="layerButtons"></div>
                </div>
                <button id="moveLayerDown" title="–°–ª–æ–π –≤–Ω–∏–∑">‚ñº</button>
             </div>
            <div class="canvas-container">
                <div class="color-picker-and-word">

                    <div class="color-picker-group">
                        <input type="color" id="colorPicker" value="#000000" title="–¶–≤–µ—Ç –∑–∞–ª–∏–≤–∫–∏ (C)">
                        <input type="color" id="colorPicker2" value="#ffffff" title="–±—É–ª—ã–π">
                        <input type="color" id="colorPicker3" value="#ff0000" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 3">
                        <input type="color" id="colorPicker4" value="#ffa500" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 4">
                        <input type="color" id="colorPicker5" value="#ffff00" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 5">
                        <input type="color" id="colorPicker6" value="#008000" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 6">
                        <input type="color" id="colorPicker7" value="#00ffff" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 7">
                        <input type="color" id="colorPicker8" value="#0000ff" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 8">
                        <input type="color" id="colorPicker9" value="#800080" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 9">
                        <div class="color-picker-group-two">
                            <input type="color" id="backgroundPicker" value="#ffffff" title="–¶–≤–µ—Ç —Ñ–æ–Ω–∞ (B)">
                            <button id="symmetry" title="–°–∏–º–º–µ—Ç—Ä–∏—è (S)">ü¶ã</button>
                        </div>
                    </div>
                    <div class="word-navigation">
                        <button id="previousWord" title="–ü—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–ª–æ–≤–æ">&lt;</button>
                        <p id="Quizz"></p>
                        <button id="nextWord" title="–°–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ">&gt;</button>
                    </div>
                    <div class="header-container">
                        <div class="time-wrapper">
                            <span id="time" class="time"></span>
                            <span id="startTime" class="time"></span>
                            <span id="elapsedTime" class="time"></span>
            <button id="zoomBtn" title="–õ—É–ø–∞"></button>
            <div id="zoomLevelDisplay" title="–£—Ä–æ–≤–µ–Ω—å –∑—É–º–∞"></div>

                        </div>

                    </div>
                </div>
                <div class="canv-container" id="canvasContainer">
    <div id="cursorPanel" class="cursor-panel" style="display: none;">
        <h3>–í—ã–±–µ—Ä–∏—Ç–µ –∫—É—Ä—Å–æ—Ä</h3>
        <div id="cursorList"></div>
     </div>
                </div>
    <div class="slider-group">
                    <div class="tools-column">
                        <label for="opacity" title="–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å">üëª</label>
                        <input type="range" id="opacity" min="1" max="100" value="100">
                        <span id="opacityValue" style="color: red;">100</span>
                    </div>
                    <div class="tools-column">
                        <label for="brushSize" title="–†–∞–∑–º–µ—Ä –∫–∏—Å—Ç–∏">üñåÔ∏è</label>
                        <input type="range" id="brushSize" min="1" max="300" value="3">
                        <span id="brushSizeValue" style="color: red;">3</span>
                    </div>
                    <div class="tools-column">
                        <div class="pressure-bar-container">
                            <label for="pressureBar" title="–ù–∞–∂–∏–º">üéØ</label>
                            <progress id="pressureBar" value="0" max="4000"></progress>
                            <span id="pressureValue" class="pressure-value"></span>
<style>
    .pressure-value {
        font-size: 12px;
        color: blue;
        margin-left: 5px;
    }
    </style>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        </div>
        </div>
        </div>
        </div>
<script>
        // Get DOM elements
            const brushSizeInput = document.getElementById('brushSize');
            const opacityInput = document.getElementById('opacity');
            const pressureBar = document.getElementById('pressureBar');
            const backgroundPicker = document.getElementById('backgroundPicker');
            const addLayerBtn = document.getElementById('addLayerBtn');
            const removeLayerBtn = document.getElementById('removeLayerBtn');
            const eraserBtn = document.getElementById('eraserBtn');
            // const isPressureSupported = 'onpointermove' in window;
            let layerCount = 0;
            const layers = [];
            const contexts = {};
            const layerColors = [];
            const history = {};
            const redoHistory = [];
            let currentLayer = 1;
            let previousLayer = 1;
            let currentCtx;
            let isDrawing = false;
            let isErasing = false;
            const layerButtons = document.getElementById('layerButtons');
            const zoomBtn = document.getElementById('zoomBtn');
            const canvasContainer = document.getElementById('canvasContainer');
            let isDrawOnExisting = false;


            drawUnderExistingBtn.addEventListener('click', toggleDrawOnExisting);

        // ZOOM CONSTANTS
            let zoomLevel =     10; // 1000% = 10
            const MAX_ZOOM = 100;
            const MIN_ZOOM = 1;
            const ZOOM_STEP = 0.02;
            let offsetX = 0;
            let offsetY = 0;
        // other constants
            Object.values(layers).forEach(addEventListenersToLayer);
            let isIdentifyingLayer = false;
            let wasDrawing = false;
            const identifyLayerBtn = document.getElementById('identifyLayerBtn');
            const layerPanel = document.querySelector('.layer-panel');
            const sidebar =document.querySelector(".sidebar")
            let isDraggingScroll = false;
            let startY;
            let lastX = 0;
            let currentCursor = 'auto'; 
            let isZoomActive = false;
        // fix
        backgroundPicker.addEventListener('input', (event) => {
          // Apply background color to the current layer
          currentCtx.fillStyle = event.target.value;
          currentCtx.fillRect(0, 0, layers[2].width, layers[2].height);
          });
        // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø 
            document.addEventListener('DOMContentLoaded', function () {
                initializeApp();
              });
        function createLayer() {
            updateZoom();
                layerCount++;
                layerColors[layerCount] = '#' + Math.floor(Math.random() * 16777215).toString(16);
                const canvas = document.createElement('canvas');
                canvas.id = `layer${layerCount}`;
                if (layerCount === 1) {
                    canvas.style.visibility = 'hidden'; // Hide the first layer
                }
                canvas.width = 600;
                canvas.height = 400;
                canvas.style.position = 'absolute';
                canvas.style.top = '0';
                canvas.style.left = '0';
                canvas.style.zIndex = layerCount;
                canvasContainer.appendChild(canvas);
                layers[layerCount] = canvas;
                contexts[layerCount] = canvas.getContext('2d');
                const button = document.createElement('button');
                button.textContent = " ‚ù§ ";
                button.classList.add('layer-button');
                button.dataset.layer = layerCount;
                layerButtons.appendChild(button);
                button.addEventListener('click', function () {
                    setCurrentLayer(parseInt(this.dataset.layer));
                });
                addEventListenersToLayer(canvas);
                setCurrentLayer(layerCount);
                initializeLayer(layerCount);
                history[layerCount] = [];
                redoHistory[layerCount] = [];
                updateLayerButtonColor(layerCount);
                updateLayerOrder();

             }
        function setCurrentLayer(layerNum) {
                if (currentLayer !== layerNum) {
                    previousLayer = currentLayer;
                }
                currentLayer = layerNum;
                currentCtx = contexts[currentLayer];
                document.querySelectorAll('.layer-button').forEach(btn => {
                    btn.classList.remove('active-layer');
                    if (parseInt(btn.dataset.layer) === currentLayer) {
                        btn.classList.add('active-layer');
                    }
                });
                if (!isErasing) {
                    updateLayerButtonColor(layerNum);
                }
                if (layerColors[layerNum]) {
                    currentCtx.strokeStyle = layerColors[layerNum];
                }
             }
        function updateLayerButtonColor(layerNum) {
            const button = document.querySelector(`.layer-button[data-layer="${layerNum}"]`);
            if (button && layerColors[layerNum]) {
                button.style.backgroundColor = layerColors[layerNum];
            }
         }
        function initializeLayer(layerNum) {
                if (layerNum === 0) {
                    contexts[layerNum].fillStyle = '#' + Math.floor(Math.random() * 16777215).toString(16);
                } else {
                    contexts[layerNum].fillStyle = 'rgba(0,0,0,0)'; // Transparent
                }
                contexts[layerNum].fillRect(0, 0, layers[layerNum].width, layers[layerNum].height);
            }
        function initializeApp() {
             createLayer();
               }
        function saveState() {
             if (!currentCtx) {
                 console.error('Error in saveState function', currentLayer);
                 return;
             }
             history[currentLayer].push(currentCtx.getImageData(0, 0, layers[currentLayer].width, layers[currentLayer]
                 .height));
             redoHistory[currentLayer] = [];
          }
        // function startDrawing(e) {
        //     if (!currentCtx) {
        //         console.error('Error: currentCtx is undefined in startDrawing.', currentLayer);
        //         return;
        //     }
            
        //     isDrawing = true;
        //     const rect = layers[currentLayer].getBoundingClientRect();
        //     const x = Math.floor((e.clientX - rect.left) / zoomLevel);
        //     const y = Math.floor((e.clientY - rect.top) / zoomLevel);
            
        //     if (isDrawOnExisting) {
        //         const imageData = currentCtx.getImageData(0, 0, layers[currentLayer].width, layers[currentLayer].height);
        //         const index = (y * layers[currentLayer].width + x) * 4;
        //         if (imageData.data[index + 3] === 0) {
        //             isDrawing = false;
        //             return; // Don't start drawing if the pixel is transparent
        //         }
        //     }
            
        //     [lastX, lastY] = [x, y];
        //     saveState();
        // }














// function startDrawing(e) {
//     if (!currentCtx) {
//         console.error('Error: currentCtx is undefined in startDrawing.', currentLayer);
//         return;
//     }
    
//     isDrawing = true;
//     const rect = layers[currentLayer].getBoundingClientRect();
//     const x = Math.floor((e.clientX - rect.left) / zoomLevel);
//     const y = Math.floor((e.clientY - rect.top) / zoomLevel);
    
//     [lastX, lastY] = [x, y];
//     saveState();
// }

const drawUnderExistingBtn = document.getElementById('drawUnderExistingBtn');

drawUnderExistingBtn.addEventListener('click', drawUnderExisting);
drawOnExistingBtn.addEventListener('click', drawOnExisting);

function drawUnderExisting() {
    isDrawOnExisting = false;
    drawUnderExistingBtn.classList.add('active');
    drawOnExistingBtn.classList.remove('active');
}

function drawOnExisting() {
    isDrawOnExisting = true;
    drawOnExistingBtn.classList.add('active');
    drawUnderExistingBtn.classList.remove('active');
}


function toggleDrawOnExisting() {
            isDrawOnExisting = !isDrawOnExisting;
            drawUnderExistingBtn.classList.toggle('active', isDrawOnExisting);
        }





function startDrawing(e) {
    if (!currentCtx) {
        console.error('Error: currentCtx is undefined in startDrawing.', currentLayer);
        return;
    }
    
    isDrawing = true;
    const rect = layers[currentLayer].getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / zoomLevel);
    const y = Math.floor((e.clientY - rect.top) / zoomLevel);
    
    [lastX, lastY] = [x, y];
    saveState();
}
const drawOnExistingBtn = document.getElementById('drawOnExistingBtn');

drawOnExistingBtn.addEventListener('click', toggleDrawOnExisting);

function toggleDrawOnExisting() {
    isDrawOnExisting = !isDrawOnExisting;
    drawOnExistingBtn.classList.toggle('active', isDrawOnExisting);
}

function draw(e) {
    if (!isDrawing || !currentCtx) {
        return;
    }
    const rect = layers[currentLayer].getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / zoomLevel);
    const y = Math.floor((e.clientY - rect.top) / zoomLevel);
    const pressure = e.pressure || 1;

    currentCtx.lineWidth = brushSizeInput.value * pressure;
    currentCtx.lineCap = 'round';
    currentCtx.lineJoin = 'round';
    currentCtx.globalAlpha = opacityInput.value / 100;
    currentCtx.globalCompositeOperation = isErasing ? 'destination-out' : 'source-over';

    if (isDrawOnExisting) {
        // Create a temporary canvas for the line
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = layers[currentLayer].width;
        tempCanvas.height = layers[currentLayer].height;
        const tempCtx = tempCanvas.getContext('2d');
        
        // Draw the line on the temporary canvas
        tempCtx.strokeStyle = currentCtx.strokeStyle;
        tempCtx.lineWidth = currentCtx.lineWidth;
        tempCtx.lineCap = currentCtx.lineCap;
        tempCtx.lineJoin = currentCtx.lineJoin;
        tempCtx.globalAlpha = currentCtx.globalAlpha;
        tempCtx.beginPath();
        tempCtx.moveTo(lastX, lastY);
        tempCtx.lineTo(x, y);
        tempCtx.stroke();

        // Use 'source-in' to keep only the parts of the line that overlap with non-transparent pixels
        tempCtx.globalCompositeOperation = 'source-in';
        tempCtx.drawImage(layers[currentLayer], 0, 0);

        // Draw the result back to the main canvas
        currentCtx.drawImage(tempCanvas, 0, 0);
    } else {
        currentCtx.beginPath();
        currentCtx.moveTo(lastX, lastY);
        currentCtx.lineTo(x, y);
        currentCtx.stroke();
    }

    if (symmetry) {
        const centerX = layers[currentLayer].width / 2;
        const symmetricLastX = centerX + (centerX - lastX);
        const symmetricX = centerX + (centerX - x);
        
        if (isDrawOnExisting) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = layers[currentLayer].width;
            tempCanvas.height = layers[currentLayer].height;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.strokeStyle = currentCtx.strokeStyle;
            tempCtx.lineWidth = currentCtx.lineWidth;
            tempCtx.lineCap = currentCtx.lineCap;
            tempCtx.lineJoin = currentCtx.lineJoin;
            tempCtx.globalAlpha = currentCtx.globalAlpha;
            tempCtx.beginPath();
            tempCtx.moveTo(symmetricLastX, lastY);
            tempCtx.lineTo(symmetricX, y);
            tempCtx.stroke();

            tempCtx.globalCompositeOperation = 'source-in';
            tempCtx.drawImage(layers[currentLayer], 0, 0);
            
            currentCtx.drawImage(tempCanvas, 0, 0);
        } else {
            currentCtx.beginPath();
            currentCtx.moveTo(symmetricLastX, lastY);
            currentCtx.lineTo(symmetricX, y);
            currentCtx.stroke();
        }
    }

    [lastX, lastY] = [x, y];
    pressureBar.value = pressure * 10000;
    pressureBar.nextElementSibling.textContent = Math.round(pressure * 100);
}


        function addEventListenersToLayer(layer) {
             layer.addEventListener('pointerdown', startDrawing);
             layer.addEventListener('pointermove', draw);
             layer.addEventListener('pointerup', function() {
                    if (isDrawing) {
                        isDrawing = false;
                    }
                });
          }
         document.querySelectorAll('button, input').forEach(element => {
             element.addEventListener('pointerdown', (e) => {
                 e.stopPropagation();
             });
          });
        function togglePreviousLayer() {
             [currentLayer, previousLayer] = [previousLayer, currentLayer];
             const layerButton = document.querySelector(`.layer-button[data-layer="${currentLayer}"]`);
             if (layerButton) {
                 layerButton.click();
             }
          }

        // fix –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Å–ª–æ—è
            canvasContainer.addEventListener('click', (e) => {
                 if (isIdentifyingLayer) {
                     identifyLayerClickHandler(e);
                     canvasContainer.style.cursor = 'default';
                     isDrawing = wasDrawing;
                     isIdentifyingLayer = false;
                     identifyLayerBtn.classList.remove('active');
                 }
              });
            identifyLayerBtn.addEventListener('click', () => {
                 isIdentifyingLayer = !isIdentifyingLayer;
                 identifyLayerBtn.classList.toggle('active', isIdentifyingLayer);
                 if (isIdentifyingLayer) {
                     wasDrawing = isDrawing;
                     isDrawing = false;
                     canvasContainer.style.cursor = 'crosshair';
                 } else {
                     canvasContainer.style.cursor = 'default';
                     isDrawing = wasDrawing;
                 }
              });
            function identifyLayerClickHandler(e) {
                    const rect = layers[1].getBoundingClientRect(); 
                    const x = (e.clientX - rect.left) / zoomLevel;
                    const y = (e.clientY - rect.top) / zoomLevel;

                    // Start from the top layer (highest z-index)
                    for (let i = layerCount; i >= 1; i--) { 
                        const ctx = contexts[i];
                        const pixelData = ctx.getImageData(x, y, 1, 1).data;

                        // If a pixel is found on this layer (alpha > 0)
                        if (pixelData[3] > 0) { 
                            setCurrentLayer(i);
                            console.log('Found drawing on layer:', i);
                            updateLayerButtonColor(i);

                            // Stop checking other layers
                            return; 
                        }
                    }
                }

            layerPanel.addEventListener("pointerenter", (e)=>{
                e.preventDefault();
                isDraggingScroll = true;
                startY = e.clientY;
                    });
            sidebar.addEventListener("pointerenter", (e)=>{
                e.preventDefault();
                isDraggingScroll = true;
                startY = e.clientY;
                    });
            sidebar.addEventListener('pointermove', (e) => {
                if (isDraggingScroll) {
                    const deltaY = e.clientY - startY;
                    sidebar.scrollTop += deltaY; 
                    startY = e.clientY;
                }
            });
            layerPanel.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                isDraggingScroll = true;
                startY = e.clientY;
             });

            layerPanel.addEventListener('pointermove', (e) => {
                if (isDraggingScroll) {
                    const deltaY = e.clientY - startY;
                    layerPanel.scrollTop += deltaY;
                    startY = e.clientY;
                }
             });
            layerPanel.addEventListener('pointerup', () => {
                isDraggingScroll = false;
             });
            canvasContainer.addEventListener('pointerdown', handleCanvasClick);
            function handleCanvasClick(e) {
                if (e.altKey) {
                    isDrawing=false;
                    e.preventDefault();
                    identifyLayerClickHandler(e);
                }
             }
        // –¥–æ–±–∞–≤–ª—è–µ–º —Å–ª–æ–π –ø–æ–¥ —Ç–µ–∫—É—â–∏–π
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    createLayerBelowCurrent();
            updateZoom();
                }
             });
            function createLayerBelowCurrent() {
                const layerButtons = Array.from(document.querySelectorAll('.layer-button'));
                const currentIndex = layerButtons.findIndex(btn => parseInt(btn.dataset.layer) === currentLayer);
                layerCount++;
                const newLayerNum = layerCount;
                const canvas = document.createElement('canvas');
                canvas.id = `layer${newLayerNum}`;
                canvas.width = 600;
                canvas.height = 400;
                canvas.style.position = 'absolute';
                canvas.style.top = '0';
                canvas.style.left = '0';
                canvas.style.zIndex = newLayerNum;
                if (currentIndex !== -1) {
                    canvasContainer.insertBefore(canvas, layers[currentLayer]);
                } else {
                    canvasContainer.appendChild(canvas);
                }
                layers[newLayerNum] = canvas;
                contexts[newLayerNum] = canvas.getContext('2d');
                layerColors[newLayerNum] = '#' + Math.floor(Math.random() * 16777215).toString(16);
                const button = document.createElement('button');
                button.textContent = " ‚ù§ ";
                button.classList.add('layer-button');
                button.dataset.layer = newLayerNum;
                if (currentIndex !== -1) {
                    layerButtons[currentIndex].parentNode.insertBefore(button, layerButtons[currentIndex].nextSibling);
                } else {
                    layerButtons.appendChild(button);
                }
                button.addEventListener('click', function () {
                    setCurrentLayer(parseInt(this.dataset.layer));
                });
                addEventListenersToLayer(canvas);
                history[newLayerNum] = [];
                redoHistory[newLayerNum] = [];
                setCurrentLayer(newLayerNum);
                initializeLayer(newLayerNum);
                updateLayerButtonColor(newLayerNum);
                updateLayerOrder();
             }
            function updateLayerOrder() {
                const layerButtons = Array.from(document.querySelectorAll('.layer-button'));
                layerButtons.forEach((button, index) => {
                    const layerId = parseInt(button.dataset.layer);
                    if (layers[layerId]) {
                        layers[layerId].style.zIndex = layerButtons.length - index;
                    }
                });
             }
        // –¥–≤–∏–≥–∞–µ–º —Å–ª–æ–∏ –∫–Ω–æ–ø–∫–∞–º–∏
            const moveLayerUpBtn = document.getElementById('moveLayerUp');
            const moveLayerDownBtn = document.getElementById('moveLayerDown');
            moveLayerUpBtn.addEventListener('click', () => {
                moveLayerInStack(-1);
             });
            moveLayerDownBtn.addEventListener('click', () => {
                moveLayerInStack(1);
             });
            function moveLayerInStack(direction) {
                const currentLayerButton = document.querySelector(`.layer-button[data-layer="${currentLayer}"]`);
                const targetLayerButton = direction === -1 ? currentLayerButton.previousElementSibling : currentLayerButton
                    .nextElementSibling;
                if (targetLayerButton) {
                    if (direction === -1) {
                        currentLayerButton.parentNode.insertBefore(currentLayerButton, targetLayerButton);
                    } else {
                        currentLayerButton.parentNode.insertBefore(targetLayerButton, currentLayerButton);
                    }
                    updateLayerOrder();
                    currentLayerButton.click();
                }
             }
            const layerButtonsContainer = document.getElementById('layerButtons');
        // Zoom functions
            let isCtrlPressed = false;

          document.addEventListener('keydown', (e) => {
              if (e.key === 'Control') {
                  isCtrlPressed = true;
              }
                  });
              
            //  —á—Ç–æ–±—ã –Ω–µ —Ä–∏—Å–æ–≤–∞–ª–∞—Å—å –ª–∏—à–Ω—è—è –ª–∏–Ω–∏—è
                  document.addEventListener('keyup', (e) => {
                      if (e.key === 'Control') {
                          isCtrlPressed = false;
                      }
                  });


    let zoomOriginX = 0;
    let zoomOriginY = 0;

    // canvasContainer.addEventListener('pointermove', (e) => {
    //   if (isCtrlPressed) {
    //     e.preventDefault();
    //     const rect = canvasContainer.getBoundingClientRect();
    //     const mouseX = e.clientX - rect.left;
    //     const mouseY = e.clientY - rect.top;

    //     if (lastX !== undefined) {
    //       const deltaX = e.movementX;
    //       const oldZoom = zoomLevel;
    //       zoomLevel = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, zoomLevel + deltaX * ZOOM_STEP));

    //       if (oldZoom !== zoomLevel) {
    //         // Calculate zoom origin relative to the canvas
    //         zoomOriginX = (mouseX - offsetX) / oldZoom;
    //         zoomOriginY = (mouseY - offsetY) / oldZoom;

    //         // Update offset to keep the zoom origin point under the mouse
    //         offsetX = mouseX - zoomOriginX * zoomLevel;
    //         offsetY = mouseY - zoomOriginY * zoomLevel;

    //         updateZoom();
    //       }
    //     }

    //     lastX = mouseX;
    //     lastY = mouseY;
    //   }
    // });

    canvasContainer.addEventListener('mousemove', (e) => {
      if (isCtrlPressed) {
        e.preventDefault();
        const rect = canvasContainer.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        if (lastX !== undefined) {
          const deltaX = e.movementX;
          const oldZoom = zoomLevel;
          zoomLevel = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, zoomLevel + deltaX * ZOOM_STEP));

          if (oldZoom !== zoomLevel) {
            // Calculate zoom origin relative to the canvas
            zoomOriginX = (mouseX - offsetX) / oldZoom;
            zoomOriginY = (mouseY - offsetY) / oldZoom;

            // Update offset to keep the zoom origin point under the mouse
            offsetX = mouseX - zoomOriginX * zoomLevel;
            offsetY = mouseY - zoomOriginY * zoomLevel;

            updateZoom();
          }
        }

        lastX = mouseX;
        lastY = mouseY;
      }
    });



    function updateZoom() {
      const container = document.getElementById('canvasContainer');
      const containerRect = container.getBoundingClientRect();

      Object.values(layers).forEach(layer => {
        layer.style.transformOrigin = '0 0';
        
        if (zoomLevel <= 1) {
          // Reset position when zoomed out to normal or less
          offsetX = 0;
          offsetY = 0;
          layer.style.transform = `scale(${zoomLevel})`;
          layer.style.left = '0';
          layer.style.top = '0';
        } else {
          // Apply zoom and offset
          layer.style.transform = `scale(${zoomLevel})`;
          
          // Ensure the layer stays within the container
          const layerRect = layer.getBoundingClientRect();
          offsetX = Math.min(Math.max(offsetX, containerRect.width - layerRect.width), 0);
          offsetY = Math.min(Math.max(offsetY, containerRect.height - layerRect.height), 0);
          
          layer.style.left = `${offsetX}px`;
          layer.style.top = `${offsetY}px`;
        }
      });

      canvasContainer.style.overflow = 'hidden';
      document.getElementById('zoomLevelDisplay').textContent = `üîé${(zoomLevel * 100).toFixed(0)}%`;
    }


        const cursorPanel = document.getElementById('cursorPanel');
        const canvas = document.getElementById('yourCanvasId'); 
    </script>
    <script src="script.js" defer></script>
    <script src="cursors.js" defer></script>
    <script type="module" src="tools.js" defer></script>
    <script type="module" src="constants.js" defer></script>
    <script type="module" src="tools.js" defer></script>
    <script type="module" src="main.js" defer></script>
    <script type="module" src="test.js" defer></script>
    <script type="module" src="settings.js" defer></script>
    <script type="module" src="helperFunction.js" defer></script>
    <script type="module" src="listners.js" defer></script>
    <script type="module" src="buttons.js" defer></script>
    <script type="module" src="hotkey.js" defer></script>
    </body>
 </html>