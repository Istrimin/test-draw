<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ù–∞—Å—Ç–æ—è—â–∏–π –•—É–¥–æ–∂–Ω–∏–∫</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jscolor/2.4.5/jscolor.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>


    </head>
<style>
 #zoomLevelDisplay {
    color: red; /* Set text color to red */
    font-weight: bold; /* Make the text bold */
    font-size: 16px; /* Adjust font size */
    margin-top: 10px; 
 }
/* –ø–æ—Ñ–∏–∫—Å–∏—Ç—å –ø–∞–Ω–µ–ª—å –∫—É—Ä—Å–æ—Ä–æ–≤ –¥–ª—è –ø–ª–∞–Ω—à–µ—Ç–∞ */

    </style>
<body>
<style>
    /* –î–æ–±–∞–≤–∏–º —Å—Ç–∏–ª—å –¥–ª—è —Ü–≤–µ—Ç–æ–≤–æ–≥–æ –∫—Ä—É–≥–ª—è—à–∫–∞ */
    #colorPreview {
        position: absolute;
        width: 20px; /* –®–∏—Ä–∏–Ω–∞ –∫—Ä—É–≥–ª—è—à–∫–∞ */
        height: 20px; /* –í—ã—Å–æ—Ç–∞ –∫—Ä—É–≥–ª—è—à–∫–∞ */
        border-radius: 50%; /* –°–¥–µ–ª–∞–µ–º –∫—Ä—É–≥–ª—è—à–∫–æ–º */
        border: 2px solid black; /* –û–±–≤–æ–¥–∫–∞ */
        pointer-events: none; /* –ß—Ç–æ–±—ã –∫—Ä—É–≥–ª—è—à–æ–∫ –Ω–µ –º–µ—à–∞–ª –∫–ª–∏–∫–∞–º */
        display: none; /* –°–∫—Ä—ã–≤–∞–µ–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é */
    }
</style>
    <script>
        const colorPreview = document.getElementById('colorPreview');
        const colorPicker = document.getElementById('colorPicker');

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –∫—Ä—É–≥–ª—è—à–∫–∞
        document.addEventListener('mousemove', (e) => {
            colorPreview.style.left = `${e.clientX + 5}px`; // –°–¥–≤–∏–Ω–µ–º –≤–ø—Ä–∞–≤–æ
            colorPreview.style.top = `${e.clientY + 5}px`; // –°–¥–≤–∏–Ω–µ–º –≤–Ω–∏–∑
            colorPreview.style.display = 'block'; // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫—Ä—É–≥–ª—è—à–æ–∫
        });

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ü–≤–µ—Ç–∞ –∫—Ä—É–≥–ª—è—à–∫–∞
        colorPicker.addEventListener('input', (e) => {
            colorPreview.style.backgroundColor = e.target.value; // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ü–≤–µ—Ç
        });

        // –°–∫—Ä—ã–≤–∞–µ–º –∫—Ä—É–≥–ª—è—à–æ–∫, –∫–æ–≥–¥–∞ –º—ã—à—å –ø–æ–∫–∏–¥–∞–µ—Ç –æ–±–ª–∞—Å—Ç—å
        document.addEventListener('mouseleave', () => {
            colorPreview.style.display = 'none';
        });
    </script>
    <div class="base-container">
        <div class="sidebar">
            <a href="index.html" target="_self" title="–í—ã–π—Ç–∏ –∏–∑ –∫–æ–º–∞–Ω—Ç—ã" id="exitLink">üö™</a>
            <button id="message" title="–°–æ–æ–±—â–µ–Ω–∏–µ">‚úâÔ∏è</button>

            <div id="message-container" style="display: none;">

                <p id="message"></p>
             </div>
            <div class="sidebar">
            </div>
            <button id="smoothLineBtn" title="–°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ –ª–∏–Ω–∏–π">üîÑ</button>

            <button id="fullscreenBtn" title="–ü–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π —Ä–µ–∂–∏–º">üî≤</button>


            <button id="ntc" title="–°—É–∂–µ–Ω–∏–µ –∫ —Ü–µ–Ω—Ç—Ä—É">üéØ</button>

            <button id="identifyLayerBtn" title="–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å–ª–æ–π">üîç</button>
            <button id="drawOnExistingBtn" title="–†–∏—Å–æ–≤–∞—Ç—å –Ω–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–º">‚û°Ô∏è</button>

            <input type="file" id="imageInput" accept="image/*" style="display: none;">
            <button id="UploadButton" title="–ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (U)">üå∫</button>
            <button id="saveImageBtn" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ">üé¨</button>
            <button id="eraserBtn">üßΩ</button>
            <button id="changeCursorBtn" title="–°–º–µ–Ω–∏—Ç—å –∫—É—Ä—Å–æ—Ä">üé®</button>
            <button id="undoBtn" title="–û—Ç–º–µ–Ω–∏—Ç—å (Z)">‚ü≤</button>
            <button id="redoBtn" title="–ü–æ–≤—Ç–æ—Ä–∏—Ç—å (X)">‚ü≥</button>
            <button id="clear" title="–û—á–∏—Å—Ç–∏—Ç—å">üíÄ</button>
            <button id="fillModeBtn" title="–ó–∞–ª–∏–≤–∫–∞ (F)">üåä</button>
            <button id="floodFillBtn" title="–ó–∞–ª–∏—Ç—å —Ü–≤–µ—Ç–æ–º">‚ú®</button>
            <button id="eyedropperBtn" title="–ü–∏–ø–µ—Ç–∫–∞ –∑–∞–ª–∏–≤–∫–∏ (A)">üíß</button>
            <!-- <button id="brushEyedropperBtn" title="–ü–∏–ø–µ—Ç–∫–∞ –∫–∏—Å—Ç–∏ (D)">üñåÔ∏è</button> -->
            <button id="deleteAllBtn" title="–£–¥–∞–ª–∏—Ç—å –≤—Å–µ">üóëÔ∏è</button>

            <button id="mergeLayers" title="–û–±—ä–µ–¥–∏–Ω–∏—Ç—å —Å–ª–æ–∏">üîó</button>
            <button id="settings" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏">‚öôÔ∏è</button>
          </div>
    <!-- –î–æ–±–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç –¥–ª—è —Ü–≤–µ—Ç–æ–≤–æ–≥–æ –∫—Ä—É–≥–ª—è—à–∫–∞ -->
    <div id="colorPreview"></div>
       <div class="canvas-and-sliders">
            <div class="layer-panel-wrapper">

                <button id="moveLayerUp" title="–°–ª–æ–π –≤–≤–µ—Ä—Ö">‚ñ≤</button>
                <div class="layer-panel">
                    <div id="layerButtons"></div>
                </div>
                <button id="moveLayerDown" title="–°–ª–æ–π –≤–Ω–∏–∑">‚ñº</button>
             </div>
            <div class="canvas-container">
                <div class="color-picker-and-word">

                    <div class="color-picker-group">
                        <input type="color" id="colorPicker" value="#000000" title="–¶–≤–µ—Ç –∑–∞–ª–∏–≤–∫–∏ (C)">
                        <input type="color" id="colorPicker2" value="#ffffff" title="–±—É–ª—ã–π">
                        <input type="color" id="colorPicker3" value="#ff0000" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 3">
                        <input type="color" id="colorPicker4" value="#ffa500" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 4">
                        <input type="color" id="colorPicker5" value="#ffff00" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 5">
                        <input type="color" id="colorPicker6" value="#008000" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 6">
                        <input type="color" id="colorPicker7" value="#00ffff" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 7">
                        <input type="color" id="colorPicker8" value="#0000ff" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 8">
                        <input type="color" id="colorPicker9" value="#800080" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏ 9">
                                                    <input type="color" id="backgroundPicker" value="#ffffff" title="–¶–≤–µ—Ç —Ñ–æ–Ω–∞ (B)">

    <div class="color-picker-group-two">
                            </div>
                                <button id="symmetry" title="–°–∏–º–º–µ—Ç—Ä–∏—è (S)">ü¶ã</button>

                        </div>
                        <div class="word-navigation">
                            <button id="previousWord" title="–ü—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–ª–æ–≤–æ">&lt;</button>
                            <p id="Quizz"></p>
                            <button id="nextWord" title="–°–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ">&gt;</button>
                        </div>
                        <div class="header-container">
                            <div class="time-wrapper">
                                <span id="time" class="time"></span>
                                <span id="startTime" class="time"></span>
                                <span id="elapsedTime" class="time"></span>
                <button id="zoomBtn" title="–õ—É–ø–∞"></button>
                <div id="zoomLevelDisplay" title="–£—Ä–æ–≤–µ–Ω—å –∑—É–º–∞"></div>

                            </div>

                        </div>
                    </div>
                    <div class="canv-container" id="canvasContainer">
        <div id="cursorPanel" class="cursor-panel" style="display: none;">
            <h3>–í—ã–±–µ—Ä–∏—Ç–µ –∫—É—Ä—Å–æ—Ä</h3>
            <div id="cursorList"></div>
         </div>
                    </div>
        <div class="slider-group">
                        <div class="tools-column">
                            <label for="opacity" title="–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å">üëª</label>
                            <input type="range" id="opacity" min="1" max="100" value="100">
                            <span id="opacityValue" style="color: red;">100</span>
                            <label for="layerOpacity" title="–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å —Å–ª–æ—è">üëì</label> 
                            <input type="range" id="layerOpacity" min="0" max="100" value="100">
                            <span id="layerOpacityValue" style="color: red;">100</span>
                        </div>
                        <div class="tools-column">
                            <label for="brushSize" title="–†–∞–∑–º–µ—Ä –∫–∏—Å—Ç–∏">üñåÔ∏è</label>
                            <input type="range" id="brushSize" min="1" max="300" value="3">
                            <span id="brushSizeValue" style="color: red;">3</span>
                            <div class="pressure-bar-container">
                                <label for="pressureBar" title="–ù–∞–∂–∏–º">üéØ</label>
                                <progress id="pressureBar" value="0" max="4000"></progress>
                                <span id="pressureValue" class="pressure-value"></span>

                        <div class="tools-column">
                            <label for="outlineSize" title="–†–∞–∑–º–µ—Ä –æ–±–≤–æ–¥–∫–∏">üñºÔ∏è</label>
                            <input type="range" id="outlineSize" min="0" max="20" value="0">
                            <span id="outlineSizeValue" style="color: red;">0</span>

    </div>
<style>
    .pressure-value {
        font-size: 12px;
        color: blue;
        margin-left: 5px;
    }
    </style>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        </div>
        </div>
        </div>
        </div>
<script>
            // const isPressureSupported = 'onpointermove' in window;

            const layerCreationComplete = new Event('layerCreationComplete');
            // 
            const brushSizeInput = document.getElementById('brushSize');
            const opacityInput = document.getElementById('opacity');
            const pressureBar = document.getElementById('pressureBar');
            const backgroundPicker = document.getElementById('backgroundPicker');
            const addLayerBtn = document.getElementById('addLayerBtn');
            const removeLayerBtn = document.getElementById('removeLayerBtn');
            const eraserBtn = document.getElementById('eraserBtn');
            const layerButtons = document.getElementById('layerButtons');
            const zoomBtn = document.getElementById('zoomBtn');
            const canvasContainer = document.getElementById('canvasContainer');
            const drawOnExistingBtn = document.getElementById('drawOnExistingBtn');
            const container = document.getElementById('canvasContainer');
            const containerRect = container.getBoundingClientRect();
            // other constants

            const identifyLayerBtn = document.getElementById('identifyLayerBtn');
            const layerPanel = document.querySelector('.layer-panel');
            const sidebar =document.querySelector(".sidebar")
            // –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å —Å–ª–æ—è
            const layerOpacities = {};
            const layerOpacitySlider = document.getElementById('layerOpacity');
            const layerOpacityValue = document.getElementById('layerOpacityValue');

            const layers = [];
            const contexts = {};
            const layerColors = [];
            const history = {};
            const redoHistory = [];
            let layerCount = 0;
            let currentLayer = 1;
            let previousLayer = 1;
            let currentCtx;
            let isDrawing = false;
            let isErasing = false;
            let isDrawOnExisting = false;
            let zoomLevel =     1; // 1000% = 10 –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
            let isIdentifyingLayer = false;
            let wasDrawing = false;
            let isDraggingScroll = false;
            let startY;
            let currentCursor = 'auto'; 
            let isZoomActive = false;
            let offsetX = 0;
            let offsetY = 0;
            let lastX = null;
            let lastY = null;

            // zoom
            let zoomOriginX = 0;
            let zoomOriginY = 0;
            let isCtrlPressed = false;
            const MAX_ZOOM = 100;
            const MIN_ZOOM = 1;
            const ZOOM_STEP = 0.02;
            // smooth
            let isSmoothLineMode = false;
            const smoothLineBtn = document.getElementById('smoothLineBtn');
            const points = [];

    </script>

<script>
        
            document.dispatchEvent(layerCreationComplete); 
            Object.values(layers).forEach(addEventListenersToLayer);
            drawOnExistingBtn.addEventListener('click', toggleDrawOnExisting);
            backgroundPicker.addEventListener('input', (event) => {
                contexts[0].fillStyle = event.target.value;
                contexts[0].fillRect(0, 0, layers[0].width, layers[0].height);
            });

        // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø 
            document.addEventListener('DOMContentLoaded', function () {

                initializeApp();
              });

        function setLayerBackground(layerIndex, imageUrl) {
            const img = new Image();
            img.onload = function() {
                contexts[layerIndex].drawImage(img, 0, 0, layers[layerIndex].width, layers[layerIndex].height);
            }
            img.src = imageUrl;
        }
        function createLayer() {

            updateZoom();
            if (!layers[100]) {
                const canvas = document.createElement('canvas');
                canvas.width = 600;
                canvas.height = 400;
                canvas.style.position = 'absolute';
                canvasContainer.appendChild(canvas);
                layers[0] = canvas;
                contexts[0] = canvas.getContext('2d');
                setLayerBackground(100, 'images/bg_index.jpg'); 
            }

            layerCount++;
            layerColors[layerCount] = '#' + Math.floor(Math.random() * 16777215).toString(16);
            const canvas = document.createElement('canvas');
            canvas.id = `layer${layerCount}`;
            canvas.width = 600;
            canvas.height = 400;
            canvas.style.position = 'absolute';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.zIndex = layerCount;
            canvasContainer.appendChild(canvas);
            layers[layerCount] = canvas;
            contexts[layerCount] = canvas.getContext('2d');
            const button = document.createElement('button');
            button.textContent = " ‚ù§ ";
            button.classList.add('layer-button');
            button.dataset.layer = layerCount;
            layerButtons.appendChild(button);
            button.addEventListener('click', function () {
                setCurrentLayer(parseInt(this.dataset.layer));
            });
            addEventListenersToLayer(canvas);
            setCurrentLayer(layerCount);
            initializeLayer(layerCount);
            history[layerCount] = [];
            redoHistory[layerCount] = [];
            updateLayerButtonColor(layerCount);
            updateLayerOrder();
            // –°–æ–∑–¥–∞–µ–º —Å–ª–∞–π–¥–µ—Ä –∏—Å—Ç–æ—Ä–∏–∏
            createHistorySlider(layerCount);
        }
        function setCurrentLayer(layerNum) {
          if (layerNum === 100) {
            return; 
          }
            if (!layers[layerNum] || !contexts[layerNum]) {
                console.warn(`Layer ${layerNum} does not exist. Cannot set as current layer.`);
                return;
            }

            if (currentLayer !== layerNum) {
                previousLayer = currentLayer;
            }

            currentLayer = layerNum;
            currentCtx = contexts[currentLayer];

            // Update opacity slider and value
            const opacity = layerOpacities[layerNum] || 100; // Default to 100 if not set
            layerOpacitySlider.value = opacity;
            layerOpacityValue.textContent = opacity;

            document.querySelectorAll('.layer-button').forEach(btn => {
                btn.classList.remove('active-layer');
                if (parseInt(btn.dataset.layer) === currentLayer) {
                    btn.classList.add('active-layer');
                }
            });

            if (!isErasing) {
                updateLayerButtonColor(layerNum);
            }

            if (layerColors[layerNum]) {
                currentCtx.strokeStyle = layerColors[layerNum];
            }
        }

        function updateLayerButtonColor(layerNum) {
            const button = document.querySelector(`.layer-button[data-layer="${layerNum}"]`);
            if (button && layerColors[layerNum]) {
                button.style.backgroundColor = layerColors[layerNum];
            }
         }
        function initializeLayer(layerNum) {
                if (layerNum === 0) {
                    contexts[layerNum].fillStyle = '#' + Math.floor(Math.random() * 16777215).toString(16);
                } else {
                    contexts[layerNum].fillStyle = 'rgba(0,0,0,0)'; // Transparent
                }
                contexts[layerNum].fillRect(0, 0, layers[layerNum].width, layers[layerNum].height);
            }
        function initializeApp() {
                 createLayer();
                   }


        function toggleDrawOnExisting() {
                        isDrawOnExisting = !isDrawOnExisting;
                        drawOnExistingBtn.classList.toggle('active', isDrawOnExisting);
                    }
        function startDrawing(e) {
            if (currentLayer === 100 || !currentCtx || isEyedropperActive) { // Check if eyedropper is active
                return;
            }
            
            isDrawing = true;
            const rect = layers[currentLayer].getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / zoomLevel);
            const y = Math.floor((e.clientY - rect.top) / zoomLevel);
            
            points.length = 0;
            points.push({x, y});
            
            [lastX, lastY] = [x, y];
            saveState();
        }

    function draw(e) {
        if (!isDrawing || !currentCtx) {
            return;
        }
        if (isFinger) {
            ntc(e);
            return;
        }
        const rect = layers[currentLayer].getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / zoomLevel);
        const y = Math.floor((e.clientY - rect.top) / zoomLevel);
        const pressure = e.pressure || 1;
        currentCtx.lineWidth = brushSizeInput.value * pressure;
        currentCtx.lineCap = 'round';
        currentCtx.lineJoin = 'round';
        currentCtx.globalAlpha = opacityInput.value / 100;
        currentCtx.globalCompositeOperation = isErasing ? 'destination-out' : 'source-over';

        if (isDrawOnExisting) {
            drawOnExistingContent(lastX, lastY, x, y, currentCtx);
        } else {
            currentCtx.beginPath();
            currentCtx.moveTo(lastX, lastY);
            currentCtx.lineTo(x, y);
            currentCtx.stroke();
        }

        if (symmetry) {
            const centerX = layers[currentLayer].width / 2;
            const symmetricLastX = centerX + (centerX - lastX);
            const symmetricX = centerX + (centerX - x);
            
            if (isDrawOnExisting) {
                drawOnExistingContent(symmetricLastX, lastY, symmetricX, y, currentCtx);
            } else {
                currentCtx.beginPath();
                currentCtx.moveTo(symmetricLastX, lastY);
                currentCtx.lineTo(symmetricX, y);
                currentCtx.stroke();
            }
        }

        [lastX, lastY] = [x, y];
        pressureBar.value = pressure * 10000;
        pressureBar.nextElementSibling.textContent = Math.round(pressure * 100);
        }


    function endDrawing() {
            if (isDrawing) {
                isDrawing = false;
                resetOriginalImage(currentLayer);
                const size = outlineSizes[currentLayer];
                
                if (isSmoothLineMode && points.length > 2) {
                    const output = getSmoothLine(points);
                    
                    currentCtx.beginPath();
                    currentCtx.moveTo(output[0].x, output[0].y);
                    
                    for (let i = 1; i < output.length; i++) {
                        currentCtx.lineTo(output[i].x, output[i].y);
                    }
                    
                    currentCtx.stroke();
                }
            }
        }







    function addEventListenersToLayer(layer) {
            layer.addEventListener('pointerdown', startDrawing);
            layer.addEventListener('pointermove', draw);
            layer.addEventListener('pointerup', endDrawing);
            layer.addEventListener('pointerout', endDrawing);
        }








    


</script>
// —Ä–∞–±–æ—á–µ–µ


<script>
// –ø–∏–ø–µ—Ç–∫–∞ 
    canvasContainer.addEventListener('click', handleEyedropperClick);
    canvasContainer.addEventListener('touchstart', handleEyedropperClick);
    const eyedropperBtn = document.getElementById('eyedropperBtn');
    let isEyedropperActive = false;

    eyedropperBtn.addEventListener('click', handleEyedropperActivation);
    eyedropperBtn.addEventListener('touchstart', handleEyedropperActivation);

function handleEyedropperActivation(e) {
    e.preventDefault();

    isEyedropperActive = !isEyedropperActive;
    document.body.style.cursor = isEyedropperActive ? 'url(cursors/pipette.png), auto' : 'auto';
    eyedropperBtn.classList.toggle('active');
    
    // Disable drawing when eyedropper is active
    if (isEyedropperActive) {
        isDrawing = false; // Ensure drawing is disabled
    }
}
function handleEyedropperClick(e) {
    if (!isEyedropperActive) return;
    isDrawing = false;
    e.preventDefault();
    const rect = canvasContainer.getBoundingClientRect();
    const x = Math.floor((e.clientX || e.touches[0].clientX) - rect.left);
    const y = Math.floor((e.clientY || e.touches[0].clientY) - rect.top);

    for (let i = layerCount; i > 0; i--) {
        if (layers[i] && i !== 100) {  // –ò—Å–∫–ª—é—á–∞–µ–º —Å–ª–æ–π 100 (–±—ç–∫–≥—Ä–∞—É–Ω–¥)
            const ctx = contexts[i];
            const imageData = ctx.getImageData(x, y, 1, 1);
            const [r, g, b, a] = imageData.data;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –Ω–∞ —ç—Ç–æ–º –ø–∏–∫—Å–µ–ª–µ —á—Ç–æ-—Ç–æ –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω–Ω–æ–µ (–Ω–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ–µ)
            if (a > 0) {
                const color = `rgba(${r},${g},${b},${a/255})`;
                // Update the layer button color
                const layerButton = document.querySelector(`.layer-button[data-layer="${currentLayer}"]`);
                if (layerButton) {
                    layerButton.style.backgroundColor = color; // Update the layer button color
                }
                currentCtx.strokeStyle = color;

                // Change the cursor color to the picked color
                document.body.style.cursor = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><circle cx="16" cy="16" r="10" fill="${color}" /></svg>'), auto`;
                
                isEyedropperActive = false;
                eyedropperBtn.classList.remove('active');
                return;
            }
        }
    }
    
    // –ï—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω –Ω–µ–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π –ø–∏–∫—Å–µ–ª—å –Ω–∞ –≤—Å–µ—Ö —Å–ª–æ—è—Ö, –∫—Ä–æ–º–µ –±—ç–∫–≥—Ä–∞—É–Ω–¥–∞
    isEyedropperActive = false;
    document.body.style.cursor = 'auto';
    eyedropperBtn.classList.remove('active');
}


// –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å —Å–ª–æ–µ–≤
        function togglePreviousLayer() {
             [currentLayer, previousLayer] = [previousLayer, currentLayer];
             const layerButton = document.querySelector(`.layer-button[data-layer="${currentLayer}"]`);
             if (layerButton) {
                 layerButton.click();
                     }
                  }

        // fix –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Å–ª–æ—è
            canvasContainer.addEventListener('click', (e) => {
                 if (isIdentifyingLayer) {
                     identifyLayerClickHandler(e);
                     canvasContainer.style.cursor = 'default';
                     isDrawing = wasDrawing;
                     isIdentifyingLayer = false;
                     identifyLayerBtn.classList.remove('active');
                 }
              });
        // –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Å–ª–æ—è
            identifyLayerBtn.addEventListener('click', () => {
                 isIdentifyingLayer = !isIdentifyingLayer;
                 identifyLayerBtn.classList.toggle('active', isIdentifyingLayer);
                 if (isIdentifyingLayer) {
                     wasDrawing = isDrawing;
                     isDrawing = false;
                     canvasContainer.style.cursor = 'crosshair';
                 } else {
                     canvasContainer.style.cursor = 'auto';
                     isDrawing = wasDrawing;
                 }
              });
            function identifyLayerClickHandler(e) {
                const rect = layers[1].getBoundingClientRect();
                const x = (e.clientX - rect.left) / zoomLevel;
                const y = (e.clientY - rect.top) / zoomLevel;
                
                // Start from the top layer (highest z-index), excluding background layer
                for (let i = layerCount; i >= 1; i--) {
                    const ctx = contexts[i];
                    const pixelData = ctx.getImageData(x, y, 1, 1).data;
                    // If a pixel is found on this layer (alpha > 0)
                    if (pixelData[3] > 0) {
                        setCurrentLayer(i);
                        updateLayerButtonColor(i);
                        return;
                    }
                }
            }


            layerPanel.addEventListener("pointerenter", (e)=>{
                e.preventDefault();
                isDraggingScroll = true;
                startY = e.clientY;
                    });
            sidebar.addEventListener("pointerenter", (e)=>{
                e.preventDefault();
                isDraggingScroll = true;
                startY = e.clientY;
                    });
            sidebar.addEventListener('pointermove', (e) => {
                if (isDraggingScroll) {
                    const deltaY = e.clientY - startY;
                    sidebar.scrollTop += deltaY; 
                    startY = e.clientY;
                }
            });
            layerPanel.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                isDraggingScroll = true;
                startY = e.clientY;
             });

            layerPanel.addEventListener('pointermove', (e) => {
                if (isDraggingScroll) {
                    const deltaY = e.clientY - startY;
                    layerPanel.scrollTop += deltaY;
                    startY = e.clientY;
                }
             });
            layerPanel.addEventListener('pointerup', () => {
                isDraggingScroll = false;
             });
            canvasContainer.addEventListener('pointerdown', handleCanvasClick);
            function handleCanvasClick(e) {
                if (e.altKey) {
                    isDrawing=false;
                    e.preventDefault();
                    identifyLayerClickHandler(e);
                }
             }
        // –¥–æ–±–∞–≤–ª—è–µ–º —Å–ª–æ–π –ø–æ–¥ —Ç–µ–∫—É—â–∏–π
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    createLayerBelowCurrent();
            updateZoom();
                }
             });
            function createLayerBelowCurrent() {
                const layerButtons = Array.from(document.querySelectorAll('.layer-button'));
                const currentIndex = layerButtons.findIndex(btn => parseInt(btn.dataset.layer) === currentLayer);
                layerCount++;
                const newLayerNum = layerCount;
                const canvas = document.createElement('canvas');
                canvas.id = `layer${newLayerNum}`;
                canvas.width = 600;
                canvas.height = 400;
                canvas.style.position = 'absolute';
                canvas.style.top = '0';
                canvas.style.left = '0';
                canvas.style.zIndex = newLayerNum;
                if (currentIndex !== -1) {
                    canvasContainer.insertBefore(canvas, layers[currentLayer]);
                } else {
                    canvasContainer.appendChild(canvas);
                }
                layers[newLayerNum] = canvas;
                contexts[newLayerNum] = canvas.getContext('2d');
                layerColors[newLayerNum] = '#' + Math.floor(Math.random() * 16777215).toString(16);
                const button = document.createElement('button');
                button.textContent = " ‚ù§ ";
                button.classList.add('layer-button');
                button.dataset.layer = newLayerNum;
                if (currentIndex !== -1) {
                    layerButtons[currentIndex].parentNode.insertBefore(button, layerButtons[currentIndex].nextSibling);
                } else {
                    layerButtons.appendChild(button);
                }
                button.addEventListener('click', function () {
                    setCurrentLayer(parseInt(this.dataset.layer));
                });
                addEventListenersToLayer(canvas);
                history[newLayerNum] = [];
                redoHistory[newLayerNum] = [];
                setCurrentLayer(newLayerNum);
                initializeLayer(newLayerNum);
                updateLayerButtonColor(newLayerNum);
                updateLayerOrder();
             }
            function updateLayerOrder() {
                    const layerButtons = Array.from(document.querySelectorAll('.layer-button'));
                    layerButtons.forEach((button, index) => {
                        const layerId = parseInt(button.dataset.layer);
                        if (layers[layerId] && layerId !== 0) {
                            layers[layerId].style.zIndex = layerButtons.length - index + 110; // +110 —á—Ç–æ–±—ã –±—ã—Ç—å –≤—ã—à–µ —Ñ–æ–Ω–∞
                        }
                    });
                }

        // –¥–≤–∏–≥–∞–µ–º —Å–ª–æ–∏ –∫–Ω–æ–ø–∫–∞–º–∏
            const moveLayerUpBtn = document.getElementById('moveLayerUp');
            const moveLayerDownBtn = document.getElementById('moveLayerDown');
            moveLayerUpBtn.addEventListener('click', () => {
                moveLayerInStack(-1);
             });
            moveLayerDownBtn.addEventListener('click', () => {
                moveLayerInStack(1);
             });
            function moveLayerInStack(direction) {
                const currentLayerButton = document.querySelector(`.layer-button[data-layer="${currentLayer}"]`);
                const targetLayerButton = direction === -1 ? currentLayerButton.previousElementSibling : currentLayerButton
                    .nextElementSibling;
                if (targetLayerButton) {
                    if (direction === -1) {
                        currentLayerButton.parentNode.insertBefore(currentLayerButton, targetLayerButton);
                    } else {
                        currentLayerButton.parentNode.insertBefore(targetLayerButton, currentLayerButton);
                    }
                    updateLayerOrder();
                    currentLayerButton.click();
                }
             }
            const layerButtonsContainer = document.getElementById('layerButtons');
        // Zoom functions

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Control') {
                    isCtrlPressed = true;
                }
            });
                                      
            document.addEventListener('keyup', (e) => {
                if (e.key === 'Control') {
                    isCtrlPressed = false;
                }
            });



            canvasContainer.addEventListener('mousemove', (e) => {
                if (!isEyedropperActive) return;
                if (!isCtrlPressed){return;}
                if (isCtrlPressed) {
                    e.preventDefault();
                    const rect = canvasContainer.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    if (lastX !== undefined) {
                        const deltaX = e.movementX;
                        const oldZoom = zoomLevel;
                        zoomLevel = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, zoomLevel + deltaX * ZOOM_STEP));

                        if (oldZoom !== zoomLevel) {
                            zoomOriginX = (mouseX - offsetX) / oldZoom;
                            zoomOriginY = (mouseY - offsetY) / oldZoom;

                            offsetX = mouseX - zoomOriginX * zoomLevel;
                            offsetY = mouseY - zoomOriginY * zoomLevel;

                            updateZoom();
                        }
                    }

                    lastX = mouseX;
                    lastY = mouseY;
                }

            });




        function updateZoom() {

            
          Object.values(layers).forEach(layer => {

            layer.style.transformOrigin = '0 0';
            
            if (zoomLevel <= 1) {
              offsetX = 0;
              offsetY = 0;
              layer.style.transform = `scale(${zoomLevel})`;
              layer.style.left = '0';
              layer.style.top = '0';
            } else {
              layer.style.transform = `scale(${zoomLevel})`;
              
              const layerRect = layer.getBoundingClientRect();
              offsetX = Math.min(Math.max(offsetX, containerRect.width - layerRect.width), 0);
              offsetY = Math.min(Math.max(offsetY, containerRect.height - layerRect.height), 0);
              
              layer.style.left = `${offsetX}px`;
              layer.style.top = `${offsetY}px`;
            }
          });

          canvasContainer.style.overflow = 'hidden';
        // –∏–∫–æ–Ω–∫–∞ –∏ –∑—É–º –≤ html
          document.getElementById('zoomLevelDisplay').textContent = `üîé${(zoomLevel * 100).toFixed(0)}%`;
        }


</script>
    <script src="script.js" defer></script>
    <script src="cursors.js" defer></script>
    <script type="module" src="tools.js" defer></script>
    <script type="module" src="constants.js" defer></script>
    <script type="module" src="tools.js" defer></script>
    <script type="module" src="main.js" defer></script>
    <script type="module" src="test.js" defer></script>
    <script type="module" src="settings.js" defer></script>
    <script type="module" src="helperFunction.js" defer></script>
    <script type="module" src="listners.js" defer></script>
    <script type="module" src="buttons.js" defer></script>
    <script type="module" src="hotkey.js" defer></script>
<script>


    //  –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –ø–∞–ª–µ—Ü
            let isFinger = false;

            const narrowToCenterBtn = document.getElementById('ntc');

            narrowToCenterBtn.addEventListener('click', () => {
                isFinger = !isFinger;
                narrowToCenterBtn.classList.toggle('active', isFinger);
            });
    function ntc(e) {
        if (!isDrawing || !currentCtx || !isFinger) return;

        const rect = layers[currentLayer].getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / zoomLevel);
        const y = Math.floor((e.clientY - rect.top) / zoomLevel);

        const brushSize = parseInt(brushSizeInput.value);
        const halfBrushSize = brushSize / 2;

        currentCtx.save();
        currentCtx.beginPath();
        currentCtx.arc(x, y, halfBrushSize, 0, Math.PI * 2);
        currentCtx.clip();

        if (lastX !== null && lastY !== null) {
            const dx = x - lastX;
            const dy = y - lastY;
            currentCtx.drawImage(
                layers[currentLayer],
                x - halfBrushSize - dx, y - halfBrushSize - dy, brushSize, brushSize,
                x - halfBrushSize, y - halfBrushSize, brushSize, brushSize
            );
        }

        currentCtx.restore();

        lastX = x;
        lastY = y;
    }
    // —Å–ª–∞–π–¥–µ—Ä –∏—Å—Ç–æ—Ä–∏–∏

        function resetOriginalImage(layerNum) {
            delete originalImages[layerNum];

        }

                const historySliders = {};
                let currentHistorySlider;
                const MAX_HISTORY_STATES = 50;

            function createHistorySlider() {
                const sliderContainer = document.createElement('div');
                sliderContainer.classList.add('history-slider-container');

                const label = document.createElement('label');
                sliderContainer.appendChild(label);

                historySlider = document.createElement('input');
                historySlider.type = 'range';
                historySlider.min = '0';
                historySlider.max = '0';
                historySlider.value = '0';
                historySlider.classList.add('history-slider');
                sliderContainer.appendChild(historySlider);

                historySlider.addEventListener('input', function() {
                    restoreLayerState(currentLayer, parseInt(this.value)); // Restore state for the current layer
                });
            }
            function saveState() {
                if (!currentCtx) {
                    return;
                }

                if (history[currentLayer].length >= MAX_HISTORY_STATES) {
                    history[currentLayer].shift(); // Remove the oldest state
                }

                history[currentLayer].push(currentCtx.getImageData(0, 0, layers[currentLayer].width, layers[currentLayer].height));
                redoHistory[currentLayer] = [];

                historySlider.max = history[currentLayer].length - 1;
                historySlider.value = history[currentLayer].length - 1;
            }



    // —Ä–∏—Å–æ–≤–∞–Ω–∏–µ –Ω–∞ –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω–Ω–æ–º
            function drawOnExistingContent(startX, startY, endX, endY, ctx) {
                const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
                const data = imageData.data;

                // –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ö–æ–ª—Å—Ç –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è –ª–∏–Ω–∏–∏
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = ctx.canvas.width;
                tempCanvas.height = ctx.canvas.height;
                const tempCtx = tempCanvas.getContext('2d');

                // –û—Ç–∫–ª—é—á–∞–µ–º —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ
                tempCtx.imageSmoothingEnabled = false;

                // –†–∏—Å—É–µ–º –ª–∏–Ω–∏—é –Ω–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ–º —Ö–æ–ª—Å—Ç–µ
                tempCtx.strokeStyle = ctx.strokeStyle;
                tempCtx.lineWidth = ctx.lineWidth;
                tempCtx.lineCap = ctx.lineCap;
                tempCtx.lineJoin = ctx.lineJoin;
                tempCtx.globalAlpha = ctx.globalAlpha;
                tempCtx.beginPath();
                tempCtx.moveTo(startX, startY);
                tempCtx.lineTo(endX, endY);
                tempCtx.stroke();

                // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–∏–∫—Å–µ–ª–µ–π –ª–∏–Ω–∏–∏
                const lineData = tempCtx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height).data;

                // –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –∫–∞–∂–¥–æ–º—É –ø–∏–∫—Å–µ–ª—é –∏ —Ä–∏—Å—É–µ–º —Ç–æ–ª—å–∫–æ —Ç–∞–º, –≥–¥–µ —É–∂–µ –µ—Å—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] > 0 && lineData[i + 3] > 0) {
                        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–æ–ª–µ–µ —Å—Ç—Ä–æ–≥–æ–µ —É—Å–ª–æ–≤–∏–µ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –ø–∏–∫—Å–µ–ª–µ–π
                        if (lineData[i + 3] > 200) {  // –ö–æ–ø–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∞–ª—å—Ñ–∞-–∫–∞–Ω–∞–ª –ª–∏–Ω–∏–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤—ã—Å–æ–∫
                            data[i] = lineData[i];
                            data[i + 1] = lineData[i + 1];
                            data[i + 2] = lineData[i + 2];
                            data[i + 3] = lineData[i + 3];
                        }
                    }
                }

                // –ü—Ä–∏–º–µ–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫ –æ—Å–Ω–æ–≤–Ω–æ–º—É —Ö–æ–ª—Å—Ç—É
                ctx.putImageData(imageData, 0, 0);
            }


    // –æ–±–≤–æ–¥–∫–∞

        const originalImages = {};
        const outlineSizes = {};

        const outlineSizeInput = document.getElementById('outlineSize');
        const outlineSizeValue = document.getElementById('outlineSizeValue');

        outlineSizeInput.max = "5";

        outlineSizeInput.addEventListener('input', function() {
            // –°–±—Ä–æ—Å –≤—Å–µ—Ö –æ–±–≤–æ–¥–æ–∫
            Object.keys(layers).forEach(key => {
                const layer = layers[key];
                const layerCtx = contexts[key];
                if (originalImages[key]) {
                    layerCtx.putImageData(originalImages[key], 0, 0);
                }
            });

            const size = parseInt(this.value);
            outlineSizeValue.textContent = size;
            applyOutline(currentLayer, size);
        });

        function applyOutline(layerNum, size) {


            if (!layers[layerNum] || !contexts[layerNum]) {
                return;
            }
            const canvas = layers[layerNum];
            const ctx = contexts[layerNum];

            // RESET OUTLINE BEFORE APPLYING NEW ONE
            if (!originalImages[layerNum]) {
                originalImages[layerNum] = ctx.getImageData(0, 0, canvas.width, canvas.height);
            } else {
                ctx.putImageData(originalImages[layerNum], 0, 0); // Restore to original before applying new outline
            }

            outlineSizes[layerNum] = size;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–ª–æ—è –≤–º–µ—Å—Ç–æ originalImages
            tempCtx.drawImage(canvas, 0, 0);
            tempCtx.putImageData(originalImages[layerNum], 0, 0);

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (size === 0) {
                ctx.putImageData(originalImages[layerNum], 0, 0);
                return; // Exit if size is 0
            }
            
            const originalStrokeStyle = ctx.strokeStyle; 

            ctx.lineWidth = size;
            ctx.strokeStyle = 'black';

            const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const index = (y * canvas.width + x) * 4;
                    if (data[index + 3] > 0) {
                        ctx.beginPath();
                        ctx.arc(x, y, size / 2, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
            }

            ctx.drawImage(tempCanvas, 0, 0);
            ctx.strokeStyle = originalStrokeStyle; 
        }



        function updateOutlineForLayer(layerNum) {

            if (!layers[layerNum] || !contexts[layerNum]) {
                console.warn(`Layer ${layerNum} does not exist. Skipping outline update.`);
                return;
            }

            const size = outlineSizes[layerNum] || 0;
            outlineSizeInput.value = size;
            outlineSizeValue.textContent = size;
            applyOutline(layerNum, size);

        }



    </script>
<script>
    // !
            // document.querySelectorAll('button, input').forEach(element => {
            //      element.addEventListener('pointerdown', (e) => {
            //          e.stopPropagation();
            //      });
            //   });


    // 2
        // function drawOnExistingContent(startX, startY, endX, endY, ctx) {
        //     const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        //     const data = imageData.data;

        //     // –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ö–æ–ª—Å—Ç –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è –ª–∏–Ω–∏–∏
        //     const tempCanvas = document.createElement('canvas');
        //     tempCanvas.width = ctx.canvas.width;
        //     tempCanvas.height = ctx.canvas.height;
        //     const tempCtx = tempCanvas.getContext('2d');

        //     // –û—Ç–∫–ª—é—á–∞–µ–º —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ
        //     tempCtx.imageSmoothingEnabled = false;

        //     // –†–∏—Å—É–µ–º –ª–∏–Ω–∏—é –Ω–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ–º —Ö–æ–ª—Å—Ç–µ
        //     tempCtx.strokeStyle = ctx.strokeStyle;
        //     tempCtx.lineWidth = ctx.lineWidth;
        //     tempCtx.lineCap = ctx.lineCap;
        //     tempCtx.lineJoin = ctx.lineJoin;
        //     tempCtx.globalAlpha = ctx.globalAlpha;
        //     tempCtx.beginPath();
        //     tempCtx.moveTo(startX, startY);
        //     tempCtx.lineTo(endX, endY);
        //     tempCtx.stroke();

        //     // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–∏–∫—Å–µ–ª–µ–π –ª–∏–Ω–∏–∏
        //     const lineData = tempCtx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height).data;

        //     // –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –∫–∞–∂–¥–æ–º—É –ø–∏–∫—Å–µ–ª—é –∏ —Ä–∏—Å—É–µ–º —Ç–æ–ª—å–∫–æ —Ç–∞–º, –≥–¥–µ —É–∂–µ –µ—Å—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç
        //     for (let i = 0; i < data.length; i += 4) {
        //         if (data[i + 3] > 0 && lineData[i + 3] > 0) {
        //             // –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–æ–ª–µ–µ —Å—Ç—Ä–æ–≥–æ–µ —É—Å–ª–æ–≤–∏–µ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –ø–∏–∫—Å–µ–ª–µ–π
        //             if (lineData[i + 3] > 200) {  // –ö–æ–ø–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∞–ª—å—Ñ–∞-–∫–∞–Ω–∞–ª –ª–∏–Ω–∏–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤—ã—Å–æ–∫
        //                 data[i] = lineData[i];
        //                 data[i + 1] = lineData[i + 1];
        //                 data[i + 2] = lineData[i + 2];
        //                 data[i + 3] = lineData[i + 3];
        //             }
        //         }
        //     }

        //     // –ü—Ä–∏–º–µ–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫ –æ—Å–Ω–æ–≤–Ω–æ–º—É —Ö–æ–ª—Å—Ç—É
        //     ctx.putImageData(imageData, 0, 0);
        // }
    </script>
    </body>
 </html>